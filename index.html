<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a2e">
    <title>Rat Factor ðŸŽ¾</title>
    <link rel="manifest" href="manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Press+Start+2P&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root {
            --bg-dark: #1a1a2e;
            --bg-card: #16213e;
            --accent-yellow: #f0e130;
            --accent-green: #00ff88;
            --accent-pink: #ff6b9d;
            --text-light: #eaeaea;
            --text-muted: #8892a0;
            --border-subtle: rgba(255,255,255,0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Space Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-light);
            min-height: 100vh;
            min-height: 100dvh;
            overflow-x: hidden;
        }

        /* Noise texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0.03;
            pointer-events: none;
            z-index: 1000;
        }

        .app-container {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 100px;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 30px 0 20px;
            position: relative;
        }

        .header h1 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 4rem;
            letter-spacing: 4px;
            color: var(--accent-yellow);
            text-shadow: 3px 3px 0 var(--accent-pink);
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .header .subtitle {
            font-size: 0.7rem;
            color: var(--text-muted);
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .header .rat {
            font-size: 2rem;
            margin: 10px 0 0;
            display: inline-block;
            animation: ratScurry 2s ease-in-out;
            animation-fill-mode: forwards;
        }

        @keyframes ratScurry {
            0% {
                transform: translateX(-100vw) scaleX(-1) rotate(0deg);
            }
            5% {
                transform: translateX(-90vw) scaleX(-1) rotate(-5deg);
            }
            10% {
                transform: translateX(-80vw) scaleX(-1) rotate(5deg);
            }
            15% {
                transform: translateX(-70vw) scaleX(-1) rotate(-5deg);
            }
            20% {
                transform: translateX(-60vw) scaleX(-1) rotate(5deg);
            }
            25% {
                transform: translateX(-50vw) scaleX(-1) rotate(-5deg);
            }
            30% {
                transform: translateX(-40vw) scaleX(-1) rotate(5deg);
            }
            35% {
                transform: translateX(-30vw) scaleX(-1) rotate(-5deg);
            }
            40% {
                transform: translateX(-20vw) scaleX(-1) rotate(5deg);
            }
            45% {
                transform: translateX(20px) scaleX(-1) rotate(0deg);
            }
            50% {
                transform: translateX(20px) scaleX(-1) rotate(0deg);
            }
            55% {
                transform: translateX(20px) scaleX(1) rotate(0deg);
            }
            60% {
                transform: translateX(15px) scaleX(1) rotate(-5deg);
            }
            65% {
                transform: translateX(10px) scaleX(1) rotate(5deg);
            }
            70% {
                transform: translateX(-5px) scaleX(1) rotate(-5deg);
            }
            75% {
                transform: translateX(0px) scaleX(1) rotate(5deg);
            }
            80% {
                transform: translateX(3px) scaleX(1) rotate(-2deg);
            }
            90% {
                transform: translateX(-1px) scaleX(1) rotate(2deg);
            }
            100% {
                transform: translateX(0) scaleX(1) rotate(0deg);
            }
        }

        /* Navigation tabs */
        .nav-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 25px;
            overflow-x: auto;
            padding-bottom: 5px;
        }

        .nav-tab {
            flex: 1;
            min-width: fit-content;
            padding: 12px 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-muted);
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .nav-tab:hover {
            border-color: var(--accent-yellow);
        }

        .nav-tab.active {
            background: var(--accent-yellow);
            color: var(--bg-dark);
            border-color: var(--accent-yellow);
            font-weight: 700;
        }

        /* Sections */
        .section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .card-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 2px;
            color: var(--accent-green);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        /* Leaderboard - WSL Championship style */
        #leaderboard {
            display: flex;
            flex-direction: column;
            overflow-x: auto;
        }

        .leaderboard-table {
            width: 100%;
            min-width: fit-content;
        }

        .leaderboard-header {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 2px solid var(--accent-yellow);
            font-size: 0.65rem;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-transform: uppercase;
            font-weight: 700;
        }

        .leaderboard-header-rank {
            width: 50px;
            text-align: center;
            flex-shrink: 0;
        }
        .leaderboard-header-name {
            width: 140px;
            padding-left: 5px;
            flex-shrink: 0;
        }
        .leaderboard-header-event {
            width: 45px;
            text-align: center;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .leaderboard-header-event .event-icon {
            font-size: 0.7rem;
        }
        .leaderboard-header-event .event-location {
            font-size: 0.5rem;
            color: var(--text-muted);
            opacity: 0.7;
            max-width: 45px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .leaderboard-header-pts {
            width: 55px;
            text-align: center;
            flex-shrink: 0;
            margin-left: auto;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-subtle);
            transition: all 0.2s ease;
        }

        .leaderboard-item:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-rank {
            width: 50px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.6rem;
            text-align: center;
            color: var(--text-muted);
            line-height: 1;
            flex-shrink: 0;
        }


        .leaderboard-player {
            width: 140px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .leaderboard-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--card-bg);
            border: 2px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.75rem;
            color: var(--text-muted);
            overflow: hidden;
            flex-shrink: 0;
        }

        .leaderboard-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .leaderboard-name {
            font-weight: 700;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .leaderboard-events {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }

        .leaderboard-event-score {
            width: 45px;
            text-align: center;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            flex-shrink: 0;
        }

        .leaderboard-event-score.not-counting {
            text-decoration: line-through;
            color: var(--text-muted);
            opacity: 0.5;
        }

        .leaderboard-event-score.first-place {
            color: #ffd700;
            font-weight: 700;
        }

        .leaderboard-event-score.second-place {
            color: #c0c0c0;
        }

        .leaderboard-event-score.third-place {
            color: var(--text-muted);
        }

        .leaderboard-event-score.no-play {
            color: var(--text-muted);
            opacity: 0.3;
        }

        .leaderboard-total {
            width: 55px;
            text-align: center;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.6rem;
            color: var(--accent-yellow);
            line-height: 1;
            flex-shrink: 0;
            margin-left: auto;
        }

        /* Leader row highlight */
        .leaderboard-item.leader {
            background: linear-gradient(90deg, rgba(240, 225, 48, 0.12) 0%, rgba(240, 225, 48, 0.03) 100%);
            border-left: 3px solid var(--accent-yellow);
        }

        .leaderboard-item.leader .leaderboard-name {
            color: var(--accent-yellow);
        }

        /* Championship footer */
        .championship-subtitle {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 15px;
            letter-spacing: 1px;
            text-align: center;
        }

        /* Points gap from leader */
        .points-gap {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            font-weight: 400;
            color: var(--accent-pink);
            background: rgba(255, 107, 157, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* Form elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .form-select, .form-input {
            width: 100%;
            padding: 14px;
            background: var(--bg-dark);
            border: 2px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-light);
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            transition: border-color 0.2s ease;
            appearance: none;
        }

        .form-select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%238892a0' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 45px;
        }

        .form-select:focus, .form-input:focus {
            outline: none;
            border-color: var(--accent-yellow);
        }

        .form-select option {
            background: var(--bg-dark);
        }

        /* Player selection grid */
        .player-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .player-toggle {
            padding: 15px;
            background: var(--bg-dark);
            border: 2px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-light);
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .player-toggle:hover {
            border-color: var(--accent-green);
        }

        .player-toggle.selected {
            background: var(--accent-green);
            color: var(--bg-dark);
            border-color: var(--accent-green);
            font-weight: 700;
        }

        .player-toggle.winner {
            background: var(--accent-yellow);
            color: var(--bg-dark);
            border-color: var(--accent-yellow);
        }

        /* Score inputs */
        .score-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .score-input-group {
            text-align: center;
        }

        .score-input-group label {
            display: block;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .score-input {
            width: 100%;
            padding: 12px;
            background: var(--bg-dark);
            border: 2px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--accent-yellow);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            text-align: center;
        }

        .score-input:focus {
            outline: none;
            border-color: var(--accent-yellow);
        }

        /* Submit button */
        .btn-submit {
            width: 100%;
            padding: 18px;
            background: var(--accent-yellow);
            border: none;
            border-radius: 8px;
            color: var(--bg-dark);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .btn-submit:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(240, 225, 48, 0.3);
        }

        .btn-submit:active {
            transform: translateY(0);
        }

        .btn-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Match history */
        .match-item {
            background: var(--bg-dark);
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 3px solid var(--accent-green);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .match-item:hover {
            transform: translateX(4px);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
        }

        .match-item:last-child {
            margin-bottom: 0;
        }

        .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .match-type {
            font-size: 0.65rem;
            color: var(--bg-dark);
            background: var(--accent-pink);
            letter-spacing: 1px;
            text-transform: uppercase;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 4px;
        }

        .match-players {
            font-size: 0.95rem;
            margin-bottom: 5px;
        }

        .match-winner {
            color: var(--accent-green);
            font-weight: 700;
        }

        .match-result {
            font-size: 1rem;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .match-def {
            color: var(--text-muted);
            font-size: 0.7rem;
            font-style: italic;
            padding: 0 6px;
        }

        .match-loser {
            color: var(--text-muted);
        }

        .match-sets {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            color: var(--accent-yellow);
            letter-spacing: 3px;
            margin-bottom: 8px;
        }

        .match-date {
            font-size: 0.7rem;
            color: var(--text-muted);
            opacity: 0.7;
        }

        /* Rat Factor match display */
        .match-item-ratfactor {
            border-left-color: var(--accent-yellow);
        }

        .ratfactor-scores {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .ratfactor-player {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
        }

        .ratfactor-player.first {
            background: rgba(240, 225, 48, 0.15);
        }

        .ratfactor-rank {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.9rem;
            color: var(--text-muted);
            width: 30px;
        }

        .ratfactor-player.first .ratfactor-rank {
            color: var(--accent-yellow);
        }

        .ratfactor-name {
            flex: 1;
            font-weight: 600;
        }

        .ratfactor-player.first .ratfactor-name {
            color: var(--accent-green);
        }

        .ratfactor-score {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            color: var(--accent-yellow);
            min-width: 25px;
            text-align: right;
        }

        /* Head to head */
        .h2h-year-section {
            margin-bottom: 30px;
        }

        .h2h-year-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 2px;
            color: var(--accent-yellow);
            margin-bottom: 15px;
            text-align: center;
        }

        .h2h-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }

        .h2h-matchup {
            background: var(--bg-dark);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 15px;
            transition: all 0.2s ease;
        }

        .h2h-matchup:hover {
            border-color: var(--accent-yellow);
            transform: translateY(-2px);
        }

        .h2h-players {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .h2h-player {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 1px;
        }

        .h2h-vs {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.9rem;
            color: var(--accent-pink);
        }

        .h2h-score {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .h2h-score-number {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            color: var(--accent-yellow);
        }

        .h2h-score-separator {
            font-size: 1.5rem;
            color: var(--text-muted);
        }

        .h2h-matches {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-align: center;
            letter-spacing: 1px;
        }

        .h2h-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .h2h-match-list {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-subtle);
        }

        .h2h-match-detail {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .h2h-match-winner {
            color: var(--accent-green);
            font-weight: 600;
        }

        .h2h-match-scores {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.85rem;
            color: var(--accent-yellow);
            letter-spacing: 1px;
        }

        .h2h-match-date {
            font-size: 0.6rem;
            opacity: 0.7;
        }

        /* Insights */
        #insights {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .insight-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 16px 18px;
            background: var(--bg-dark);
            border-left: 4px solid var(--accent-green);
            border-radius: 0 10px 10px 0;
            font-size: 0.9rem;
            line-height: 1.6;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .insight-item:hover {
            transform: translateX(4px);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        }

        .insight-emoji {
            font-size: 1.4rem;
            flex-shrink: 0;
            width: 28px;
            text-align: center;
        }

        .insight-text {
            flex: 1;
            color: var(--text-light);
        }

        .insight-text strong {
            color: var(--accent-green);
            font-weight: 700;
        }

        .insight-item.streak {
            border-left-color: var(--accent-pink);
        }

        .insight-item.streak .insight-text strong {
            color: var(--accent-pink);
        }

        .insight-item.doubles {
            border-left-color: var(--accent-yellow);
        }

        .insight-item.doubles .insight-text strong {
            color: var(--accent-yellow);
        }

        .insight-item.dominance {
            border-left-color: #9b59b6;
        }

        .insight-item.dominance .insight-text strong {
            color: #9b59b6;
        }

        .insight-item.cold {
            border-left-color: #3498db;
        }

        .insight-item.cold .insight-text strong {
            color: #3498db;
        }

        .insight-item.stat {
            border-left-color: var(--accent-green);
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--accent-green);
            color: var(--bg-dark);
            padding: 15px 25px;
            border-radius: 8px;
            font-weight: 700;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.error {
            background: var(--accent-pink);
        }

        /* Edit button */
        .match-edit-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 8px 12px;
            font-size: 1rem;
            opacity: 0.5;
            transition: opacity 0.2s;
            position: relative;
            z-index: 10;
        }
        .match-edit-btn:hover {
            opacity: 1;
            color: var(--accent-yellow);
        }
        .match-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .match-location {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 5px;
        }

        /* Edit Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 25px;
            width: 90%;
            max-width: 400px;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        .modal-overlay.show .modal {
            transform: scale(1);
        }
        .modal-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-yellow);
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }
        .modal-btn-cancel {
            background: var(--border-subtle);
            color: var(--text-primary);
        }
        .modal-btn-save {
            background: var(--accent-yellow);
            color: var(--bg-dark);
        }
        .modal-btn:hover {
            transform: translateY(-2px);
        }

        /* Loading spinner */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        #leaderboard.loading {
            flex-direction: row;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-subtle);
            border-top-color: var(--accent-yellow);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Team display for doubles */
        .team-section {
            margin-bottom: 15px;
        }

        .team-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        /* Canadian doubles specific */
        .canadian-players {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .canadian-player-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-dark);
            border-radius: 8px;
        }

        .canadian-player-name {
            flex: 1;
            font-weight: 700;
        }

        .canadian-player-score {
            width: 60px;
        }

        .canadian-player-score input {
            width: 100%;
            padding: 8px;
            background: transparent;
            border: 2px solid var(--border-subtle);
            border-radius: 6px;
            color: var(--accent-yellow);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            text-align: center;
        }

        .canadian-player-score input:focus {
            outline: none;
            border-color: var(--accent-yellow);
        }

        /* Tennis set inputs */
        #setsContainer {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 10px;
        }

        .set-row {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--bg-dark);
            padding: 10px 12px;
            border-radius: 8px;
        }

        .set-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            min-width: 45px;
        }

        .set-score-input {
            width: 50px;
            padding: 8px;
            background: transparent;
            border: 2px solid var(--border-subtle);
            border-radius: 6px;
            color: var(--accent-yellow);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            text-align: center;
        }

        .set-score-input:focus {
            outline: none;
            border-color: var(--accent-yellow);
        }

        .set-separator {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            color: var(--text-muted);
        }

        .set-remove-btn {
            background: none;
            border: none;
            color: var(--accent-pink);
            font-size: 1.3rem;
            cursor: pointer;
            padding: 0 5px;
            line-height: 1;
        }

        .set-remove-btn:hover {
            color: #ff4777;
        }

        .btn-add-set {
            background: transparent;
            border: 2px dashed var(--border-subtle);
            border-radius: 8px;
            color: var(--text-muted);
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-add-set:hover {
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        /* Tiebreak input */
        .tiebreak-group {
            display: none;
            align-items: center;
            gap: 5px;
            margin-left: 8px;
        }

        .tiebreak-group.visible {
            display: flex;
        }

        .tiebreak-label {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .tiebreak-input {
            width: 40px;
            padding: 6px;
            background: transparent;
            border: 2px solid var(--accent-pink);
            border-radius: 6px;
            color: var(--accent-pink);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            text-align: center;
        }

        .tiebreak-input:focus {
            outline: none;
            border-color: var(--accent-yellow);
        }

        /* Singles sets container */
        #singlesSetsContainer {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 10px;
        }

        /* Fighter Select Button */
        .btn-fighter-select {
            width: 100%;
            padding: 16px 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%);
            border: 2px solid var(--accent-pink);
            border-radius: 8px;
            color: var(--accent-pink);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255, 107, 157, 0.2);
        }

        .btn-fighter-select:hover {
            background: var(--accent-pink);
            color: var(--bg-dark);
            box-shadow: 0 0 30px rgba(255, 107, 157, 0.5);
            transform: scale(1.02);
        }

        .btn-fighter-select .btn-icon {
            font-size: 1.4rem;
        }

        /* Fighter Select Overlay */
        .fighter-select-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a12 0%, #1a1a2e 50%, #0f0f1a 100%);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
        }

        .fighter-select-overlay.active {
            display: flex;
        }

        /* Animated background grid */
        .fighter-select-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(255, 107, 157, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 107, 157, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Scanline effect */
        .fighter-select-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
        }

        .fighter-select-content {
            position: relative;
            z-index: 1;
            width: 100%;
            max-width: 600px;
            padding: 30px 20px;
        }

        .fighter-select-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .fighter-select-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.1rem;
            color: var(--accent-yellow);
            text-shadow:
                0 0 10px var(--accent-yellow),
                0 0 20px var(--accent-yellow),
                0 0 40px var(--accent-yellow),
                3px 3px 0 var(--accent-pink);
            animation: titleFlicker 3s ease-in-out infinite;
            letter-spacing: 2px;
        }

        @keyframes titleFlicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.8; }
            94% { opacity: 1; }
            95% { opacity: 0.9; }
            96% { opacity: 1; }
        }

        .fighter-select-subtitle {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 15px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        /* Fighter Grid */
        .fighter-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .fighter-card {
            position: relative;
            background: linear-gradient(180deg, #16213e 0%, #0f0f1a 100%);
            border: 2px solid var(--border-subtle);
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .fighter-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 107, 157, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .fighter-card:hover {
            transform: translateY(-5px) scale(1.03);
            animation: none;
        }

        /* Player-specific hover glows */
        .fighter-card[data-player="Rick"]:hover {
            border-color: #ff4444;
            box-shadow:
                0 10px 40px rgba(255, 68, 68, 0.4),
                0 0 60px rgba(255, 68, 68, 0.3),
                inset 0 0 30px rgba(255, 68, 68, 0.1);
        }
        .fighter-card[data-player="Ed"]:hover {
            border-color: #44ff44;
            box-shadow:
                0 10px 40px rgba(68, 255, 68, 0.4),
                0 0 60px rgba(68, 255, 68, 0.3),
                inset 0 0 30px rgba(68, 255, 68, 0.1);
        }
        .fighter-card[data-player="Tom"]:hover {
            border-color: #4444ff;
            box-shadow:
                0 10px 40px rgba(68, 68, 255, 0.4),
                0 0 60px rgba(68, 68, 255, 0.3),
                inset 0 0 30px rgba(68, 68, 255, 0.1);
        }
        .fighter-card[data-player="Jethro"]:hover {
            border-color: #ffff44;
            box-shadow:
                0 10px 40px rgba(255, 255, 68, 0.4),
                0 0 60px rgba(255, 255, 68, 0.3),
                inset 0 0 30px rgba(255, 255, 68, 0.1);
        }

        .fighter-card:hover::before {
            opacity: 1;
        }

        .fighter-portrait {
            width: 100%;
            aspect-ratio: 3/4;
            background: linear-gradient(135deg, #2a2a4e 0%, #1a1a2e 100%);
            border-radius: 8px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            position: relative;
            overflow: hidden;
            filter: contrast(1.1) saturate(1.2);
            transition: filter 0.3s ease;
        }

        /* Fighter image styling */
        .fighter-img {
            height: 160%;
            width: auto;
            object-fit: contain;
            object-position: top center;
            position: relative;
            z-index: 1;
            margin-top: 80%;
            animation: fighterWobble 3s cubic-bezier(0.45, 0.05, 0.55, 0.95) infinite;
            filter: drop-shadow(0 0 20px rgba(0,0,0,0.5));
        }

        .fighter-card:nth-child(2) .fighter-img { animation-delay: 0.4s; }
        .fighter-card:nth-child(3) .fighter-img { animation-delay: 0.8s; }
        .fighter-card:nth-child(4) .fighter-img { animation-delay: 1.2s; }

        @keyframes fighterWobble {
            0%, 100% { transform: translateX(0) rotate(0deg); }
            50% { transform: translateX(3px) rotate(0.5deg); }
        }

        /* Bottom vignette */
        .fighter-portrait::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 40%),
                radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.4) 100%);
            pointer-events: none;
            z-index: 1;
        }

        .fighter-card:hover .fighter-portrait {
            filter: contrast(1.2) saturate(1.4) brightness(1.1);
            transform: scale(1.02);
        }

        /* Player-specific colors */
        .fighter-card[data-player="Rick"] .fighter-img {
            width: 100%;
            height: auto;
            margin-top: 10px;
        }
        .fighter-card[data-player="Rick"] .fighter-portrait {
            background:
                radial-gradient(ellipse at 50% 80%, rgba(255, 100, 0, 0.4) 0%, transparent 50%),
                radial-gradient(ellipse at 30% 70%, rgba(255, 50, 0, 0.3) 0%, transparent 40%),
                radial-gradient(ellipse at 70% 70%, rgba(255, 150, 0, 0.3) 0%, transparent 40%),
                linear-gradient(180deg, #1a0a0a 0%, #2d1010 50%, #4a1a0a 100%);
            border-bottom: 3px solid #ff4444;
            animation: rickBackground 3s ease-in-out infinite;
        }

        @keyframes rickBackground {
            0%, 100% {
                background-position: 0% 0%, 0% 0%, 0% 0%, 0% 0%;
            }
            50% {
                background-position: 0% 5%, 5% -5%, -5% -5%, 0% 0%;
            }
        }
        .fighter-card[data-player="Ed"] .fighter-portrait {
            background: linear-gradient(135deg, #1a3d1a 0%, #1a1a2e 100%);
            border-bottom: 3px solid #44ff44;
        }
        .fighter-card[data-player="Ed"] .fighter-portrait::before {
            content: 'KINTAMANI';
            position: absolute;
            top: 12px;
            left: 0;
            right: 0;
            text-align: center;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            color: white;
            letter-spacing: 2px;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .fighter-card[data-player="Tom"] .fighter-portrait {
            background: linear-gradient(135deg, #1a1a3d 0%, #1a1a2e 100%);
            border-bottom: 3px solid #4444ff;
        }
        .fighter-card[data-player="Jethro"] .fighter-img {
            width: 100%;
            height: auto;
            margin-top: 0;
        }
        .fighter-card[data-player="Jethro"] .fighter-portrait {
            background: linear-gradient(135deg, #3d3d1a 0%, #1a1a2e 100%);
            border-bottom: 3px solid #ffff44;
        }
        .fighter-card[data-player="Jethro"] .fighter-portrait::before {
            content: 'DIESEL';
            position: absolute;
            top: 12px;
            left: 0;
            right: 0;
            text-align: center;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            color: white;
            letter-spacing: 2px;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .fighter-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            color: var(--text-light);
            text-align: center;
            letter-spacing: 3px;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .fighter-card:hover .fighter-name {
            color: var(--accent-yellow);
            text-shadow: 0 0 10px var(--accent-yellow);
        }

        .fighter-stats {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 8px;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .fighter-stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .fighter-stat-value {
            color: var(--accent-green);
            font-weight: 700;
        }

        /* Close button */
        .fighter-select-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: 2px solid var(--text-muted);
            color: var(--text-muted);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .fighter-select-close:hover {
            border-color: var(--accent-pink);
            color: var(--accent-pink);
            transform: rotate(90deg);
        }

        /* VS text for when selecting */
        .fighter-vs {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: var(--accent-pink);
            text-align: center;
            margin: 20px 0;
            opacity: 0.5;
        }

        /* Flip card styles */
        .fighter-card {
            perspective: 1000px;
        }

        .fighter-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
        }

        .fighter-card.flipped .fighter-card-inner {
            transform: rotateY(180deg);
        }

        .fighter-card-front,
        .fighter-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .fighter-card-front {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .fighter-card-back {
            transform: rotateY(180deg);
            background: linear-gradient(145deg, #1a1a2e 0%, #16213e 50%, #1a1a2e 100%);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .fighter-card-back-header {
            text-align: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--accent-pink);
        }

        .fighter-card-back-img {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            object-position: top center;
            border: 3px solid var(--accent-pink);
            margin-bottom: 8px;
            box-shadow: 0 0 20px rgba(255, 68, 170, 0.4);
        }

        .fighter-card-back-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            color: white;
            letter-spacing: 2px;
        }

        .fighter-card-back-title {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .fighter-traits {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            font-size: 0.75rem;
        }

        .fighter-trait-section {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
        }

        .fighter-trait-label {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.9rem;
            letter-spacing: 1px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .fighter-trait-label.strength {
            color: var(--accent-green);
        }

        .fighter-trait-label.weakness {
            color: var(--accent-pink);
        }

        .fighter-trait-list {
            color: var(--text-muted);
            line-height: 1.4;
        }

        .fighter-trait-item {
            margin-bottom: 4px;
        }

        /* Enlarged/modal state */
        .fighter-card-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 3000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .fighter-card-overlay.active {
            display: flex;
        }

        .fighter-card-enlarged {
            width: 90vw;
            max-width: 350px;
            height: 80vh;
            max-height: 500px;
            perspective: 1000px;
        }

        .fighter-card-enlarged .fighter-card-inner {
            width: 100%;
            height: 100%;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
            transform: rotateY(0deg);
        }

        .fighter-card-enlarged .fighter-card-inner.flipped {
            transform: rotateY(180deg);
        }

        .fighter-card-enlarged .fighter-card-front,
        .fighter-card-enlarged .fighter-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            border-radius: 16px;
            border: 3px solid var(--accent-pink);
            box-shadow: 0 0 40px rgba(255, 68, 170, 0.4);
        }

        .fighter-card-enlarged .fighter-card-front {
            background: linear-gradient(145deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .fighter-card-front-img {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            object-fit: cover;
            object-position: top center;
            border: 4px solid var(--accent-pink);
            box-shadow: 0 0 40px rgba(255, 68, 170, 0.5);
            margin-bottom: 20px;
        }

        .fighter-card-front-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            color: white;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(255, 68, 170, 0.5);
        }

        .fighter-card-front-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            color: var(--accent-pink);
            letter-spacing: 2px;
            margin-top: 5px;
        }

        .fighter-card-enlarged .fighter-card-back {
            transform: rotateY(180deg);
            padding: 20px;
        }

        .fighter-card-enlarged .fighter-card-back-name {
            font-size: 2rem;
        }

        .fighter-card-enlarged .fighter-traits {
            font-size: 1rem;
        }

        .fighter-card-enlarged .fighter-trait-section {
            padding: 12px 14px;
        }

        .fighter-card-enlarged .fighter-trait-label {
            font-size: 1.2rem;
            margin-bottom: 8px;
        }

        .fighter-card-enlarged .fighter-trait-list {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.5;
        }

        .fighter-card-enlarged .fighter-trait-item {
            margin-bottom: 6px;
            font-size: 1rem;
        }

        .fighter-card-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--text-muted);
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 3001;
            transition: all 0.3s ease;
        }

        .fighter-card-close:hover {
            border-color: var(--accent-pink);
            color: var(--accent-pink);
        }

        /* External Matches Button */
        .external-matches-btn {
            margin-top: 15px;
            padding: 12px 20px;
            background: linear-gradient(135deg, var(--accent-pink) 0%, #ff6b9d 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            letter-spacing: 1px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 68, 170, 0.3);
        }

        .external-matches-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 68, 170, 0.4);
        }

        /* External Matches Modal */
        .external-matches-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 4000;
            overflow-y: auto;
            padding: 20px;
        }

        .external-matches-overlay.active {
            display: block;
        }

        .external-matches-content {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }

        .external-matches-close {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--text-muted);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 4001;
        }

        .external-matches-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2rem;
            color: var(--accent-pink);
            text-align: center;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }

        .external-matches-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 25px;
        }

        .external-opponent-summary {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 10px 15px;
            text-align: center;
            min-width: 100px;
        }

        .external-opponent-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            color: white;
            margin-bottom: 4px;
        }

        .external-opponent-record {
            font-size: 0.85rem;
            color: var(--accent-green);
        }

        .external-opponent-record.negative {
            color: var(--accent-pink);
        }

        .external-matches-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .external-match-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--border-subtle);
            border-radius: 10px;
            padding: 12px 15px;
        }

        .external-match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .external-match-opponent {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            color: white;
        }

        .external-match-date {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .external-match-score {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .external-match-result {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-left: 8px;
        }

        .external-match-result.win {
            background: rgba(68, 255, 68, 0.2);
            color: var(--accent-green);
        }

        .external-match-result.loss {
            background: rgba(255, 68, 170, 0.2);
            color: var(--accent-pink);
        }

        .external-match-type {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-style: italic;
            margin-top: 5px;
        }

        /* Matchup Section Styles */
        .matchup-description {
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 20px;
            font-size: 0.95rem;
        }

        .btn-spin-wheel {
            margin-top: 0;
        }

        .matchup-result {
            margin-top: 30px;
            animation: fadeInUp 0.5s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .matchup-teams {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .matchup-team {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            width: 100%;
            border: 2px solid rgba(255, 107, 157, 0.3);
        }

        .matchup-team.team-1 {
            border-color: rgba(255, 107, 157, 0.5);
            box-shadow: 0 0 20px rgba(255, 107, 157, 0.15);
        }

        .matchup-team.team-2 {
            border-color: rgba(68, 255, 68, 0.5);
            box-shadow: 0 0 20px rgba(68, 255, 68, 0.15);
        }

        .team-label {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            letter-spacing: 2px;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        .team-players {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .team-player {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: playerReveal 0.5s ease backwards;
        }

        .team-1 .team-player {
            color: var(--accent-pink);
        }

        .team-2 .team-player {
            color: var(--accent-green);
        }

        @keyframes playerReveal {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .team-ampersand {
            color: var(--text-muted);
            font-family: 'Space Mono', monospace;
            font-size: 1.2rem;
        }

        .matchup-vs {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2rem;
            letter-spacing: 4px;
            color: var(--text-primary);
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            animation: vsFlash 0.8s ease;
        }

        @keyframes vsFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .btn-spin-again {
            width: 100%;
            padding: 12px 20px;
            background: transparent;
            border: 1px solid var(--accent-pink);
            border-radius: 8px;
            color: var(--accent-pink);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 25px;
            text-transform: uppercase;
        }

        .btn-spin-again:hover {
            background: rgba(255, 107, 157, 0.1);
        }

        /* Interactive Wheel Styles */
        .wheel-phase {
            display: none;
        }

        .wheel-phase.active {
            display: block;
        }

        .wheel-player-select {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .wheel-player-btn {
            padding: 25px 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: var(--text-primary);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .wheel-player-btn:hover {
            background: rgba(255, 107, 157, 0.1);
            border-color: var(--accent-pink);
        }

        .wheel-player-btn:active {
            transform: scale(0.98);
        }

        .wheel-container {
            position: relative;
            width: 100%;
            max-width: 320px;
            margin: 20px auto;
            touch-action: none;
            user-select: none;
        }

        .wheel-canvas {
            width: 100%;
            aspect-ratio: 1;
            cursor: grab;
            display: block;
        }

        .wheel-canvas:active {
            cursor: grabbing;
        }

        .wheel-pointer {
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            transform-origin: right center;
            display: flex;
            align-items: center;
            transition: transform 0.05s ease-out;
        }

        /* The flipper arm */
        .wheel-pointer::before {
            content: '';
            width: 45px;
            height: 14px;
            background: linear-gradient(to bottom,
                #f0f0f0 0%,
                #d0d0d0 20%,
                #a0a0a0 50%,
                #808080 80%,
                #606060 100%);
            border-radius: 3px 8px 8px 3px;
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.5),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
            border: 1px solid #555;
        }

        /* The mounting bracket/pivot point */
        .wheel-pointer::after {
            content: '';
            position: absolute;
            right: -8px;
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg,
                #e0e0e0 0%,
                #b0b0b0 30%,
                #808080 70%,
                #505050 100%);
            border-radius: 50%;
            box-shadow:
                0 3px 6px rgba(0, 0, 0, 0.5),
                inset 0 2px 3px rgba(255, 255, 255, 0.4),
                inset 0 -2px 3px rgba(0, 0, 0, 0.3);
            border: 2px solid #444;
        }

        .wheel-pointer.tick {
            animation: flipperBounce 0.1s ease-out;
        }

        @keyframes flipperBounce {
            0% { transform: translateY(-50%) rotate(0deg); }
            50% { transform: translateY(-50%) rotate(-12deg); }
            100% { transform: translateY(-50%) rotate(0deg); }
        }

        .wheel-instruction {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 15px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .wheel-selected-player {
            text-align: center;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 2px;
            color: var(--accent-pink);
            margin-bottom: 10px;
        }

        .btn-change-player {
            width: 100%;
            padding: 12px 20px;
            background: transparent;
            border: 1px solid var(--text-muted);
            border-radius: 8px;
            color: var(--text-muted);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.9rem;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
            text-transform: uppercase;
        }

        .btn-change-player:hover {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
        }

        .result-buttons {
            display: flex;
            gap: 10px;
            margin-top: 25px;
        }

        .result-buttons .btn-spin-again {
            flex: 1;
            margin-top: 0;
        }

        .result-buttons .btn-change-player {
            flex: 1;
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1>RAT FACTOR</h1>
            <p class="subtitle">Lets see it</p>
            <div class="rat">ðŸ€</div>
        </header>

        <nav class="nav-tabs">
            <button class="nav-tab active" data-section="home">Home</button>
            <button class="nav-tab" data-section="log">Log Match</button>
            <button class="nav-tab" data-section="history">History</button>
            <button class="nav-tab" data-section="h2h">H2H</button>
            <button class="nav-tab" data-section="matchup">Matchup</button>
        </nav>

        <!-- HOME SECTION -->
        <section id="home" class="section active">
            <div class="card">
                <h2 class="card-title">ðŸ€ Rat Factor Championship</h2>
                <div id="leaderboard" class="loading">
                    <div class="spinner"></div>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">ðŸ’¡ Insights</h2>
                <div id="insights">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

        </section>

        <!-- LOG MATCH SECTION -->
        <section id="log" class="section">
            <div class="card">
                <h2 class="card-title">ðŸ“ Log New Match</h2>
                
                <div class="form-group">
                    <label class="form-label">Match Type</label>
                    <select id="matchType" class="form-select">
                        <option value="">Select type...</option>
                        <option value="singles">Singles (1v1)</option>
                        <option value="doubles">Doubles (2v2)</option>
                        <option value="canadian">Rat Factor (3 players)</option>
                    </select>
                </div>

                <div id="matchForm" style="display: none;"></div>
            </div>
        </section>

        <!-- HISTORY SECTION -->
        <section id="history" class="section">
            <div class="card">
                <h2 class="card-title">ðŸ“œ Match History</h2>
                <div id="matchHistory">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>
        </section>

        <!-- HEAD TO HEAD SECTION -->
        <section id="h2h" class="section">
            <div class="card">
                <h2 class="card-title">âš”ï¸ Head to Head</h2>
                <div id="h2hGrid">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

            <button class="btn-fighter-select" onclick="openFighterSelect()">
                <span class="btn-icon">ðŸŽ®</span>
                Fighter Select
            </button>
        </section>

        <!-- MATCHUP SECTION -->
        <section id="matchup" class="section">
            <div class="card">
                <h2 class="card-title">ðŸŽ² Doubles Matchup</h2>

                <!-- Phase 1: Player Selection -->
                <div id="wheelPhase1" class="wheel-phase active">
                    <p class="matchup-description">Who are you?</p>
                    <div id="wheelPlayerSelect" class="wheel-player-select">
                        <!-- Buttons generated by JS -->
                    </div>
                </div>

                <!-- Phase 2: Wheel Spin -->
                <div id="wheelPhase2" class="wheel-phase">
                    <div class="wheel-selected-player">Playing as: <span id="wheelSelectedName"></span></div>
                    <div class="wheel-container" id="wheelContainer">
                        <canvas id="wheelCanvas" class="wheel-canvas"></canvas>
                        <div class="wheel-pointer"></div>
                    </div>
                    <p class="wheel-instruction" id="wheelInstruction">Swipe or drag to spin!</p>
                    <button class="btn-change-player" onclick="showWheelPhase(1)">Change Player</button>
                </div>

                <!-- Phase 3: Result Display -->
                <div id="wheelPhase3" class="wheel-phase">
                    <div id="matchupResult" class="matchup-result">
                        <div class="matchup-teams">
                            <div class="matchup-team team-1">
                                <div class="team-label">TEAM 1</div>
                                <div class="team-players">
                                    <span class="team-player" id="team1Player1"></span>
                                    <span class="team-ampersand">&</span>
                                    <span class="team-player" id="team1Player2"></span>
                                </div>
                            </div>
                            <div class="matchup-vs">VS</div>
                            <div class="matchup-team team-2">
                                <div class="team-label">TEAM 2</div>
                                <div class="team-players">
                                    <span class="team-player" id="team2Player1"></span>
                                    <span class="team-ampersand">&</span>
                                    <span class="team-player" id="team2Player2"></span>
                                </div>
                            </div>
                        </div>
                        <div class="result-buttons">
                            <button class="btn-spin-again" onclick="resetWheelForSpin()">
                                <span class="btn-icon">ðŸ”„</span>
                                Spin Again
                            </button>
                            <button class="btn-change-player" onclick="showWheelPhase(1)">
                                Change Player
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <!-- Fighter Select Overlay -->
    <div id="fighterSelect" class="fighter-select-overlay">
        <button class="fighter-select-close" onclick="closeFighterSelect()">âœ•</button>
        <div class="fighter-select-content">
            <div class="fighter-select-header">
                <h1 class="fighter-select-title">SELECT YOUR FIGHTER</h1>
                <p class="fighter-select-subtitle">Choose wisely</p>
            </div>
            <div class="fighter-grid">
                <div class="fighter-card" data-player="Rick">
                    <div class="fighter-portrait">
                        <img src="rick images/angler.png" alt="Rick" class="fighter-img">
                    </div>
                    <div class="fighter-name">Rick</div>
                    <div class="fighter-stats">
                        <span class="fighter-stat">W: <span class="fighter-stat-value" id="rick-wins">-</span></span>
                        <span class="fighter-stat">L: <span class="fighter-stat-value" id="rick-losses">-</span></span>
                        <span class="fighter-stat">RF: <span class="fighter-stat-value" id="rick-rf">-</span></span>
                    </div>
                </div>
                <div class="fighter-card" data-player="Ed">
                    <div class="fighter-portrait">
                        <img src="ed images/gein.png" alt="Ed" class="fighter-img">
                    </div>
                    <div class="fighter-name">Ed</div>
                    <div class="fighter-stats">
                        <span class="fighter-stat">W: <span class="fighter-stat-value" id="ed-wins">-</span></span>
                        <span class="fighter-stat">L: <span class="fighter-stat-value" id="ed-losses">-</span></span>
                        <span class="fighter-stat">RF: <span class="fighter-stat-value" id="ed-rf">-</span></span>
                    </div>
                </div>
                <div class="fighter-card" data-player="Tom">
                    <div class="fighter-portrait">
                        <img src="tom images/drdeath.png" alt="Tom" class="fighter-img">
                    </div>
                    <div class="fighter-name">Tom</div>
                    <div class="fighter-stats">
                        <span class="fighter-stat">W: <span class="fighter-stat-value" id="tom-wins">-</span></span>
                        <span class="fighter-stat">L: <span class="fighter-stat-value" id="tom-losses">-</span></span>
                        <span class="fighter-stat">RF: <span class="fighter-stat-value" id="tom-rf">-</span></span>
                    </div>
                </div>
                <div class="fighter-card" data-player="Jethro">
                    <div class="fighter-portrait">
                        <img src="jethro images/diesel.png" alt="Jethro" class="fighter-img">
                    </div>
                    <div class="fighter-name">Jethro</div>
                    <div class="fighter-stats">
                        <span class="fighter-stat">W: <span class="fighter-stat-value" id="jethro-wins">-</span></span>
                        <span class="fighter-stat">L: <span class="fighter-stat-value" id="jethro-losses">-</span></span>
                        <span class="fighter-stat">RF: <span class="fighter-stat-value" id="jethro-rf">-</span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Fighter Card Enlarged Overlay -->
    <div id="fighterCardOverlay" class="fighter-card-overlay" onclick="closeFighterCard(event)">
        <button class="fighter-card-close" onclick="closeFighterCard(event)">&times;</button>
        <div class="fighter-card-enlarged">
            <div class="fighter-card-inner" id="fighterCardInner">
                <div class="fighter-card-front">
                    <img id="enlargedFighterImgFront" class="fighter-card-front-img" src="" alt="">
                    <div class="fighter-card-front-name" id="enlargedFighterNameFront"></div>
                    <div class="fighter-card-front-title" id="enlargedFighterTitleFront"></div>
                </div>
                <div class="fighter-card-back">
                    <div class="fighter-card-back-header">
                        <img id="enlargedFighterImg" class="fighter-card-back-img" src="" alt="">
                        <div class="fighter-card-back-name" id="enlargedFighterName"></div>
                        <div class="fighter-card-back-title" id="enlargedFighterTitle"></div>
                    </div>
                    <div class="fighter-traits">
                        <div class="fighter-trait-section">
                            <div class="fighter-trait-label strength">ðŸ’ª STRENGTHS</div>
                            <div class="fighter-trait-list" id="enlargedFighterStrengths"></div>
                        </div>
                        <div class="fighter-trait-section">
                            <div class="fighter-trait-label weakness">âš¡ WEAKNESSES</div>
                            <div class="fighter-trait-list" id="enlargedFighterWeaknesses"></div>
                        </div>
                        <div class="fighter-trait-section">
                            <div class="fighter-trait-label" style="color: var(--accent-yellow);">ðŸ“Š STATS</div>
                            <div class="fighter-trait-list" id="enlargedFighterStats"></div>
                        </div>
                        <div id="externalMatchesBtn" class="external-matches-btn" style="display: none;" onclick="openExternalMatches(event)">
                            ðŸŽ¾ External Matches
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- External Matches Modal -->
    <div id="externalMatchesModal" class="external-matches-overlay" onclick="closeExternalMatches(event)">
        <div class="external-matches-content" onclick="event.stopPropagation()">
            <button class="external-matches-close" onclick="closeExternalMatches(event)">&times;</button>
            <h2 class="external-matches-title">External Matches</h2>
            <div class="external-matches-summary" id="externalMatchesSummary"></div>
            <div class="external-matches-list" id="externalMatchesList"></div>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <!-- Edit Match Modal -->
    <div id="editModal" class="modal-overlay" onclick="closeEditModal(event)">
        <div class="modal" onclick="event.stopPropagation()" style="max-width: 450px;">
            <div class="modal-title">Edit Match</div>
            <input type="hidden" id="editMatchId">
            <input type="hidden" id="editMatchType">

            <!-- Singles Sets Section (shown only for singles matches) -->
            <div id="editSinglesSection" style="display: none;">
                <div class="form-group">
                    <label class="form-label">Sets</label>
                    <div id="editSinglesSetsContainer"></div>
                    <button class="btn-add-set" onclick="addEditSinglesSet()">+ Add Set</button>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Location</label>
                <input type="text" id="editLocation" class="form-input" placeholder="e.g. Tom's Court, The Park">
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" onclick="closeEditModal()">Cancel</button>
                <button class="modal-btn modal-btn-save" onclick="saveMatchEdit()">Save</button>
            </div>
        </div>
    </div>

    <script>
        // Supabase setup
        const SUPABASE_URL = 'https://osbbviimzoqaeyneogtp.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_7LNEQqzEeiCw_giwIWP44g_8M7_cxvz';
        const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        const PLAYERS = ['Rick', 'Ed', 'Tom', 'Jethro'];

        // State
        let matches = [];

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            initNavigation();
            initMatchTypeSelector();
            loadMatches();

            // Global click handler for edit buttons (event delegation)
            document.addEventListener('click', (e) => {
                const editBtn = e.target.closest('.match-edit-btn');
                if (editBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    const matchData = {
                        id: editBtn.dataset.matchId,
                        matchType: editBtn.dataset.matchType,
                        location: editBtn.dataset.location || '',
                        player1: editBtn.dataset.player1,
                        player2: editBtn.dataset.player2,
                        sets: editBtn.dataset.sets || ''
                    };
                    openEditModal(matchData);
                }
            });

            // Add click handler for fighter cards using event delegation
            document.addEventListener('click', (e) => {
                const fighterCard = e.target.closest('.fighter-card');
                if (fighterCard && fighterCard.dataset.player) {
                    e.preventDefault();
                    e.stopPropagation();
                    openFighterCard(fighterCard.dataset.player);
                }
            });
        });

        // Navigation
        function initNavigation() {
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.section).classList.add('active');
                });
            });
        }

        // Match type selector
        function initMatchTypeSelector() {
            document.getElementById('matchType').addEventListener('change', (e) => {
                renderMatchForm(e.target.value);
            });
        }

        // Render match form based on type
        function renderMatchForm(type) {
            const container = document.getElementById('matchForm');
            
            if (!type) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            if (type === 'singles') {
                container.innerHTML = `
                    <div class="form-group">
                        <label class="form-label">Player 1</label>
                        <select id="singlesP1" class="form-select">
                            <option value="">Select player...</option>
                            ${PLAYERS.map(p => `<option value="${p}">${p}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Player 2</label>
                        <select id="singlesP2" class="form-select">
                            <option value="">Select player...</option>
                            ${PLAYERS.map(p => `<option value="${p}">${p}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Sets</label>
                        <div id="singlesSetsContainer">
                            <div class="set-row" data-set="1">
                                <span class="set-label">Set 1</span>
                                <input type="number" class="set-score-input" data-player="1" min="0" placeholder="0" onchange="checkSinglesTiebreak(this)">
                                <span class="set-separator">-</span>
                                <input type="number" class="set-score-input" data-player="2" min="0" placeholder="0" onchange="checkSinglesTiebreak(this)">
                                <div class="tiebreak-group">
                                    <span class="tiebreak-label">(</span>
                                    <input type="number" class="tiebreak-input" data-tb="1" min="0" placeholder="0" style="width:35px;">
                                    <span class="tiebreak-label">-</span>
                                    <input type="number" class="tiebreak-input" data-tb="2" min="0" placeholder="0" style="width:35px;">
                                    <span class="tiebreak-label">)</span>
                                </div>
                                <button class="set-remove-btn" onclick="removeSinglesSet(this)" style="visibility: hidden;">Ã—</button>
                            </div>
                        </div>
                        <button class="btn-add-set" onclick="addSinglesSet()">+ Add Set</button>
                    </div>
                    <button class="btn-submit" onclick="submitSingles()">LOG MATCH</button>
                `;
            } else if (type === 'doubles') {
                container.innerHTML = `
                    <div class="team-section">
                        <div class="team-label">TEAM 1</div>
                        <div class="player-grid">
                            ${PLAYERS.map(p => `<button class="player-toggle" data-team="1" data-player="${p}">${p}</button>`).join('')}
                        </div>
                    </div>
                    <div class="team-section">
                        <div class="team-label">TEAM 2</div>
                        <div class="player-grid">
                            ${PLAYERS.map(p => `<button class="player-toggle" data-team="2" data-player="${p}">${p}</button>`).join('')}
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Sets</label>
                        <div id="setsContainer">
                            <div class="set-row" data-set="1">
                                <span class="set-label">Set 1</span>
                                <input type="number" class="set-score-input" data-team="1" min="0" max="7" placeholder="0">
                                <span class="set-separator">-</span>
                                <input type="number" class="set-score-input" data-team="2" min="0" max="7" placeholder="0">
                                <button class="set-remove-btn" onclick="removeSet(this)" style="visibility: hidden;">Ã—</button>
                            </div>
                        </div>
                        <button class="btn-add-set" onclick="addSet()">+ Add Set</button>
                    </div>
                    <button class="btn-submit" onclick="submitDoubles()">LOG MATCH</button>
                `;

                // Team selection logic
                document.querySelectorAll('.player-toggle').forEach(btn => {
                    btn.addEventListener('click', handleDoublesPlayerToggle);
                });
            } else if (type === 'canadian') {
                container.innerHTML = `
                    <div class="form-group">
                        <label class="form-label">Select 3 Players</label>
                        <div class="player-grid">
                            ${PLAYERS.map(p => `<button class="player-toggle canadian-toggle" data-player="${p}">${p}</button>`).join('')}
                        </div>
                    </div>
                    <div id="canadianScores" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">Final Scores</label>
                            <div class="canadian-players" id="canadianPlayerScores"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Target Score</label>
                            <select id="canadianTarget" class="form-select">
                                <option value="11">First to 11</option>
                                <option value="7">First to 7</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Location (optional)</label>
                            <input type="text" id="canadianLocation" class="form-input" placeholder="e.g. Tom's Court, The Park">
                        </div>
                    </div>
                    <button class="btn-submit" onclick="submitCanadian()">LOG MATCH</button>
                `;

                document.querySelectorAll('.canadian-toggle').forEach(btn => {
                    btn.addEventListener('click', handleCanadianPlayerToggle);
                });
            }
        }

        function updateSinglesWinnerOptions() {
            const p1 = document.getElementById('singlesP1').value;
            const p2 = document.getElementById('singlesP2').value;
            const winnerSelect = document.getElementById('singlesWinner');
            
            winnerSelect.innerHTML = '<option value="">Select winner...</option>';
            if (p1) winnerSelect.innerHTML += `<option value="${p1}">${p1}</option>`;
            if (p2 && p2 !== p1) winnerSelect.innerHTML += `<option value="${p2}">${p2}</option>`;
        }

        function handleDoublesPlayerToggle(e) {
            const btn = e.target;
            const team = btn.dataset.team;
            const player = btn.dataset.player;

            // Check if player is already on the other team
            const otherTeam = team === '1' ? '2' : '1';
            const otherTeamBtn = document.querySelector(`.player-toggle[data-team="${otherTeam}"][data-player="${player}"].selected`);
            if (otherTeamBtn) {
                otherTeamBtn.classList.remove('selected');
            }

            btn.classList.toggle('selected');

            // Limit to 2 per team
            const teamSelected = document.querySelectorAll(`.player-toggle[data-team="${team}"].selected`);
            if (teamSelected.length > 2) {
                teamSelected[0].classList.remove('selected');
            }
        }

        // Singles set management functions
        function addSinglesSet() {
            const container = document.getElementById('singlesSetsContainer');
            const setRows = container.querySelectorAll('.set-row');
            const newSetNum = setRows.length + 1;

            if (newSetNum > 5) {
                showToast('Maximum 5 sets allowed', true);
                return;
            }

            const newRow = document.createElement('div');
            newRow.className = 'set-row';
            newRow.dataset.set = newSetNum;
            newRow.innerHTML = `
                <span class="set-label">Set ${newSetNum}</span>
                <input type="number" class="set-score-input" data-player="1" min="0" placeholder="0" onchange="checkSinglesTiebreak(this)">
                <span class="set-separator">-</span>
                <input type="number" class="set-score-input" data-player="2" min="0" placeholder="0" onchange="checkSinglesTiebreak(this)">
                <div class="tiebreak-group">
                    <span class="tiebreak-label">(</span>
                    <input type="number" class="tiebreak-input" data-tb="1" min="0" placeholder="0" style="width:35px;">
                    <span class="tiebreak-label">-</span>
                    <input type="number" class="tiebreak-input" data-tb="2" min="0" placeholder="0" style="width:35px;">
                    <span class="tiebreak-label">)</span>
                </div>
                <button class="set-remove-btn" onclick="removeSinglesSet(this)">Ã—</button>
            `;
            container.appendChild(newRow);
            updateSinglesSetRemoveButtons();
        }

        function removeSinglesSet(btn) {
            const row = btn.closest('.set-row');
            row.remove();

            // Renumber remaining sets
            const container = document.getElementById('singlesSetsContainer');
            const setRows = container.querySelectorAll('.set-row');
            setRows.forEach((row, index) => {
                row.dataset.set = index + 1;
                row.querySelector('.set-label').textContent = `Set ${index + 1}`;
            });
            updateSinglesSetRemoveButtons();
        }

        function updateSinglesSetRemoveButtons() {
            const container = document.getElementById('singlesSetsContainer');
            const setRows = container.querySelectorAll('.set-row');
            setRows.forEach((row, index) => {
                const removeBtn = row.querySelector('.set-remove-btn');
                // Hide remove button if only one set remains
                removeBtn.style.visibility = setRows.length === 1 ? 'hidden' : 'visible';
            });
        }

        function checkSinglesTiebreak(input) {
            const row = input.closest('.set-row');
            const p1Score = parseInt(row.querySelector('.set-score-input[data-player="1"]').value) || 0;
            const p2Score = parseInt(row.querySelector('.set-score-input[data-player="2"]').value) || 0;
            const tiebreakGroup = row.querySelector('.tiebreak-group');

            // Show tiebreak input if score is 6-6, 7-6, or 6-7
            if ((p1Score === 6 && p2Score === 6) || (p1Score === 7 && p2Score === 6) || (p1Score === 6 && p2Score === 7)) {
                tiebreakGroup.classList.add('visible');
            } else {
                tiebreakGroup.classList.remove('visible');
                // Clear tiebreak value if not visible
                tiebreakGroup.querySelector('.tiebreak-input').value = '';
            }
        }

        function addSet() {
            const container = document.getElementById('setsContainer');
            const setRows = container.querySelectorAll('.set-row');
            const newSetNum = setRows.length + 1;

            if (newSetNum > 5) {
                showToast('Maximum 5 sets allowed', true);
                return;
            }

            const newRow = document.createElement('div');
            newRow.className = 'set-row';
            newRow.dataset.set = newSetNum;
            newRow.innerHTML = `
                <span class="set-label">Set ${newSetNum}</span>
                <input type="number" class="set-score-input" data-team="1" min="0" max="7" placeholder="0">
                <span class="set-separator">-</span>
                <input type="number" class="set-score-input" data-team="2" min="0" max="7" placeholder="0">
                <button class="set-remove-btn" onclick="removeSet(this)">Ã—</button>
            `;
            container.appendChild(newRow);
            updateSetRemoveButtons();
        }

        function removeSet(btn) {
            const row = btn.closest('.set-row');
            row.remove();

            // Renumber remaining sets
            const container = document.getElementById('setsContainer');
            const setRows = container.querySelectorAll('.set-row');
            setRows.forEach((row, index) => {
                row.dataset.set = index + 1;
                row.querySelector('.set-label').textContent = `Set ${index + 1}`;
            });
            updateSetRemoveButtons();
        }

        function updateSetRemoveButtons() {
            const container = document.getElementById('setsContainer');
            const setRows = container.querySelectorAll('.set-row');
            setRows.forEach((row, index) => {
                const removeBtn = row.querySelector('.set-remove-btn');
                // Hide remove button if only one set remains
                removeBtn.style.visibility = setRows.length === 1 ? 'hidden' : 'visible';
            });
        }

        function handleCanadianPlayerToggle(e) {
            const btn = e.target;
            btn.classList.toggle('selected');

            const selected = document.querySelectorAll('.canadian-toggle.selected');
            if (selected.length > 3) {
                selected[0].classList.remove('selected');
            }

            updateCanadianScoresUI();
        }

        function updateCanadianScoresUI() {
            const selected = Array.from(document.querySelectorAll('.canadian-toggle.selected')).map(b => b.dataset.player);
            const scoresContainer = document.getElementById('canadianScores');
            const scoresDiv = document.getElementById('canadianPlayerScores');

            if (selected.length === 3) {
                scoresContainer.style.display = 'block';
                scoresDiv.innerHTML = selected.map(player => `
                    <div class="canadian-player-row">
                        <span class="canadian-player-name">${player}</span>
                        <div class="canadian-player-score">
                            <input type="number" id="score_${player}" min="0" placeholder="0">
                        </div>
                    </div>
                `).join('');
            } else {
                scoresContainer.style.display = 'none';
            }
        }

        // Submit functions
        async function submitSingles() {
            const p1 = document.getElementById('singlesP1').value;
            const p2 = document.getElementById('singlesP2').value;

            if (!p1 || !p2 || p1 === p2) {
                showToast('Please select two different players', true);
                return;
            }

            // Collect set scores
            const setRows = document.querySelectorAll('#singlesSetsContainer .set-row');
            const sets = [];
            let p1SetsWon = 0;
            let p2SetsWon = 0;

            for (const row of setRows) {
                let p1Score = parseInt(row.querySelector('.set-score-input[data-player="1"]').value);
                let p2Score = parseInt(row.querySelector('.set-score-input[data-player="2"]').value);

                if (isNaN(p1Score) || isNaN(p2Score)) {
                    showToast('Please enter scores for all sets', true);
                    return;
                }

                const setData = { p1: p1Score, p2: p2Score };

                // Check for tiebreak (6-6, 7-6, or 6-7)
                if ((p1Score === 6 && p2Score === 6) || (p1Score === 7 && p2Score === 6) || (p1Score === 6 && p2Score === 7)) {
                    const tb1Input = row.querySelector('.tiebreak-input[data-tb="1"]');
                    const tb2Input = row.querySelector('.tiebreak-input[data-tb="2"]');
                    const tb1Score = parseInt(tb1Input.value);
                    const tb2Score = parseInt(tb2Input.value);

                    if (!isNaN(tb1Score) && !isNaN(tb2Score) && (tb1Score > 0 || tb2Score > 0)) {
                        // Store both tiebreak scores
                        setData.tb1 = tb1Score;
                        setData.tb2 = tb2Score;
                        // Also store loser's score for backward compatibility
                        setData.tiebreak = Math.min(tb1Score, tb2Score);

                        // If 6-6, auto-convert to 7-6 based on tiebreak winner
                        if (p1Score === 6 && p2Score === 6) {
                            if (tb1Score > tb2Score) {
                                setData.p1 = 7;
                                p1Score = 7;
                            } else {
                                setData.p2 = 7;
                                p2Score = 7;
                            }
                        }
                    }
                }

                sets.push(setData);

                if (p1Score > p2Score) p1SetsWon++;
                else if (p2Score > p1Score) p2SetsWon++;
            }

            if (p1SetsWon === p2SetsWon) {
                showToast('Match cannot be tied - add another set', true);
                return;
            }

            const winner = p1SetsWon > p2SetsWon ? p1 : p2;

            const match = {
                match_type: 'singles',
                player1: p1,
                player2: p2,
                winner1: winner,
                sets: JSON.stringify(sets)
            };

            await saveMatch(match);
        }

        async function submitDoubles() {
            const team1 = Array.from(document.querySelectorAll('.player-toggle[data-team="1"].selected')).map(b => b.dataset.player);
            const team2 = Array.from(document.querySelectorAll('.player-toggle[data-team="2"].selected')).map(b => b.dataset.player);

            if (team1.length !== 2 || team2.length !== 2) {
                showToast('Please select 2 players per team', true);
                return;
            }

            // Collect set scores
            const setRows = document.querySelectorAll('.set-row');
            const sets = [];
            let team1SetsWon = 0;
            let team2SetsWon = 0;

            for (const row of setRows) {
                const team1Score = parseInt(row.querySelector('.set-score-input[data-team="1"]').value);
                const team2Score = parseInt(row.querySelector('.set-score-input[data-team="2"]').value);

                if (isNaN(team1Score) || isNaN(team2Score)) {
                    showToast('Please enter scores for all sets', true);
                    return;
                }

                sets.push({ team1: team1Score, team2: team2Score });

                if (team1Score > team2Score) team1SetsWon++;
                else if (team2Score > team1Score) team2SetsWon++;
            }

            if (team1SetsWon === team2SetsWon) {
                showToast('Match cannot be tied - add another set', true);
                return;
            }

            const winners = team1SetsWon > team2SetsWon ? team1 : team2;

            const match = {
                match_type: 'doubles',
                player1: team1[0],
                player2: team1[1],
                player3: team2[0],
                player4: team2[1],
                winner1: winners[0],
                winner2: winners[1],
                sets: JSON.stringify(sets)
            };

            await saveMatch(match);
        }

        async function submitCanadian() {
            const selected = Array.from(document.querySelectorAll('.canadian-toggle.selected')).map(b => b.dataset.player);
            
            if (selected.length !== 3) {
                showToast('Please select exactly 3 players', true);
                return;
            }

            const scores = {};
            let hasScores = true;
            selected.forEach(player => {
                const scoreInput = document.getElementById(`score_${player}`);
                const score = parseInt(scoreInput.value);
                if (isNaN(score)) hasScores = false;
                scores[player] = score;
            });

            if (!hasScores) {
                showToast('Please enter all scores', true);
                return;
            }

            const target = parseInt(document.getElementById('canadianTarget').value);
            const location = document.getElementById('canadianLocation').value.trim() || null;

            const match = {
                match_type: 'canadian',
                player1: selected[0],
                player2: selected[1],
                player3: selected[2],
                score_player1: scores[selected[0]],
                score_player2: scores[selected[1]],
                score_player3: scores[selected[2]],
                target_score: target,
                location: location
            };

            await saveMatch(match);
        }

        async function saveMatch(match) {
            try {
                const { error } = await db.from('matches').insert([match]);
                
                if (error) throw error;

                showToast('Match logged! ðŸŽ¾');
                document.getElementById('matchType').value = '';
                document.getElementById('matchForm').style.display = 'none';
                loadMatches();
                
                // Switch to home tab
                document.querySelector('.nav-tab[data-section="home"]').click();
            } catch (err) {
                console.error('Error saving match:', err);
                showToast('Error saving match', true);
            }
        }

        // Load matches
        async function loadMatches() {
            try {
                const { data, error } = await db
                    .from('matches')
                    .select('*')
                    .order('created_at', { ascending: false });

                if (error) throw error;

                matches = data || [];
                renderLeaderboard();
                renderHistory();
                renderInsights();
                renderH2H();
            } catch (err) {
                console.error('Error loading matches:', err);
                document.getElementById('leaderboard').innerHTML = '<div class="empty-state">Error loading data</div>';
            }
        }

        // Render leaderboard - WSL Championship style with event columns
        function renderLeaderboard() {
            const container = document.getElementById('leaderboard');
            const currentYear = new Date().getFullYear();
            const canadianMatches = matches.filter(m =>
                m.match_type === 'canadian' &&
                new Date(m.created_at).getFullYear() === currentYear
            ).sort((a, b) => new Date(a.created_at) - new Date(b.created_at)); // Sort chronologically

            if (canadianMatches.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ€</div>No Rat Factor matches yet this year</div>';
                return;
            }

            // Player photos
            const playerPhotos = {
                'Rick': 'rick images/angler.png',
                'Ed': 'ed images/gein.png',
                'Tom': 'tom images/drdeath.png',
                'Jethro': 'jethro images/diesel.png'
            };

            // Calculate points per event for each player
            // Points: 1st = 3pts, 2nd = 1pt, 3rd = 0pts
            const playerEventResults = {};
            PLAYERS.forEach(p => playerEventResults[p] = []);

            canadianMatches.forEach((match, eventIndex) => {
                const players = [
                    { name: match.player1, score: match.score_player1 || 0 },
                    { name: match.player2, score: match.score_player2 || 0 },
                    { name: match.player3, score: match.score_player3 || 0 }
                ].filter(p => p.name);

                players.sort((a, b) => b.score - a.score);

                // Award points: 1st = 3, 2nd = 1, 3rd = 0
                const pointsMap = { 0: 3, 1: 1, 2: 0 };

                // Initialize all players as not playing this event
                PLAYERS.forEach(p => {
                    playerEventResults[p][eventIndex] = { points: null, position: null };
                });

                players.forEach((player, position) => {
                    if (player.name && playerEventResults[player.name]) {
                        playerEventResults[player.name][eventIndex] = {
                            points: pointsMap[position],
                            position: position + 1
                        };
                    }
                });
            });

            // Calculate championship standings (best 10 results)
            const standings = PLAYERS.map(name => {
                const allResults = playerEventResults[name];
                const playedResults = allResults
                    .map((r, idx) => ({ ...r, eventIndex: idx }))
                    .filter(r => r.points !== null);

                // Sort by points descending to find best 10
                const sortedByPoints = [...playedResults].sort((a, b) => b.points - a.points);
                const best10Indices = new Set(sortedByPoints.slice(0, 10).map(r => r.eventIndex));

                const totalPoints = sortedByPoints.slice(0, 10).reduce((sum, r) => sum + r.points, 0);
                const wins = sortedByPoints.slice(0, 10).filter(r => r.position === 1).length;

                return {
                    name,
                    points: totalPoints,
                    events: playedResults.length,
                    wins,
                    best10Indices,
                    eventResults: allResults
                };
            }).sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                return b.wins - a.wins;
            });

            // Build header with event columns
            const eventHeaders = canadianMatches.map((match, i) => {
                const location = match.location ? `<span class="event-location">${match.location}</span>` : '';
                return `
                    <div class="leaderboard-header-event">
                        <span class="event-icon">ðŸ€</span>
                        <span>${i + 1}</span>
                        ${location}
                    </div>
                `;
            }).join('');

            // Build player rows
            const playerRows = standings.map((player, index) => {
                // Calculate rank - players with same points share the same rank
                const rank = standings.findIndex(p => p.points === player.points) + 1;

                const photo = playerPhotos[player.name];
                const avatarContent = photo
                    ? `<img src="${photo}" alt="${player.name}">`
                    : player.name.charAt(0);

                const eventScores = player.eventResults.map((result, eventIndex) => {
                    if (result.points === null) {
                        return `<div class="leaderboard-event-score no-play">-</div>`;
                    }

                    const isCounting = player.best10Indices.has(eventIndex);
                    const positionClass = result.position === 1 ? 'first-place' :
                                         result.position === 2 ? 'second-place' : 'third-place';
                    const countingClass = isCounting ? '' : 'not-counting';

                    return `<div class="leaderboard-event-score ${positionClass} ${countingClass}">${result.points}</div>`;
                }).join('');

                return `
                    <div class="leaderboard-item rank-${rank}${rank === 1 ? ' leader' : ''}">
                        <div class="leaderboard-rank">${rank}</div>
                        <div class="leaderboard-player">
                            <div class="leaderboard-avatar">${avatarContent}</div>
                            <div class="leaderboard-name">${player.name}</div>
                        </div>
                        <div class="leaderboard-events">${eventScores}</div>
                        <div class="leaderboard-total">${player.points}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="leaderboard-table">
                    <div class="leaderboard-header">
                        <div class="leaderboard-header-rank">#</div>
                        <div class="leaderboard-header-name">Name</div>
                        ${eventHeaders}
                        <div class="leaderboard-header-pts">Pts</div>
                    </div>
                    ${playerRows}
                </div>
                <div class="championship-subtitle">${currentYear} SEASON â€¢ BEST 10 RESULTS COUNT</div>
            `;
        }

        // Render history
        function renderHistory() {
            const container = document.getElementById('matchHistory');

            if (matches.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ“œ</div>No matches logged yet</div>';
                return;
            }

            container.innerHTML = matches.slice(0, 20).map(match => {
                const date = new Date(match.created_at).toLocaleDateString('en-AU', {
                    day: 'numeric',
                    month: 'short',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                const editBtn = `<button class="match-edit-btn" data-match-id="${match.id}" data-match-type="${match.match_type}" data-location="${(match.location || '').replace(/"/g, '&quot;')}" data-player1="${match.player1}" data-player2="${match.player2}" data-sets="${(match.sets || '').replace(/"/g, '&quot;')}">âœï¸</button>`;

                if (match.match_type === 'singles') {
                    const winner = match.winner1;
                    const loser = match.winner1 === match.player1 ? match.player2 : match.player1;
                    const winnerIsP1 = match.winner1 === match.player1;
                    const singlesLocationDisplay = match.location ? `<div class="match-location">ðŸ“ ${match.location}</div>` : '';

                    // Parse sets if available (show from winner's perspective)
                    let setsDisplay = '';
                    if (match.sets) {
                        try {
                            const sets = JSON.parse(match.sets);
                            setsDisplay = sets.map(s => {
                                const winnerScore = winnerIsP1 ? s.p1 : s.p2;
                                const loserScore = winnerIsP1 ? s.p2 : s.p1;
                                let scoreStr = `${winnerScore}-${loserScore}`;
                                // Add tiebreak score if present - show both scores (e.g., "7-6 (7-1)")
                                if (s.tb1 !== undefined && s.tb2 !== undefined) {
                                    // Use stored tiebreak scores, show from winner's perspective
                                    const winnerTB = winnerIsP1 ? s.tb1 : s.tb2;
                                    const loserTB = winnerIsP1 ? s.tb2 : s.tb1;
                                    scoreStr += ` (${winnerTB}-${loserTB})`;
                                } else if (s.tiebreak !== undefined) {
                                    // Backward compatibility: calculate winner's tiebreak
                                    const loserTB = s.tiebreak;
                                    const winnerTB = loserTB >= 5 ? loserTB + 2 : 7;
                                    scoreStr += ` (${winnerTB}-${loserTB})`;
                                }
                                return scoreStr;
                            }).join(' ');
                        } catch (e) {
                            setsDisplay = '';
                        }
                    }

                    return `
                        <div class="match-item">
                            <div class="match-header">
                                <div class="match-header-left">
                                    <div class="match-type">Singles</div>
                                    <div class="match-date">${date}</div>
                                </div>
                                ${editBtn}
                            </div>
                            ${singlesLocationDisplay}
                            <div class="match-result">
                                <span class="match-winner">${winner}</span>
                                <span class="match-def">def.</span>
                                <span class="match-loser">${loser}</span>
                            </div>
                            ${setsDisplay ? `<div class="match-sets">${setsDisplay}</div>` : ''}
                        </div>
                    `;
                } else if (match.match_type === 'doubles') {
                    const team1 = `${match.player1} & ${match.player2}`;
                    const team2 = `${match.player3} & ${match.player4}`;
                    const team1Won = match.winner1 === match.player1 || match.winner1 === match.player2;
                    const winner = team1Won ? team1 : team2;
                    const loser = team1Won ? team2 : team1;

                    // Parse sets if available (show from winner's perspective)
                    let setsDisplay = '';
                    if (match.sets) {
                        try {
                            const sets = JSON.parse(match.sets);
                            setsDisplay = sets.map(s => {
                                const winnerScore = team1Won ? s.team1 : s.team2;
                                const loserScore = team1Won ? s.team2 : s.team1;
                                return `${winnerScore}-${loserScore}`;
                            }).join(' ');
                        } catch (e) {
                            setsDisplay = '';
                        }
                    }

                    const doublesLocationDisplay = match.location ? `<div class="match-location">ðŸ“ ${match.location}</div>` : '';
                    return `
                        <div class="match-item">
                            <div class="match-header">
                                <div class="match-header-left">
                                    <div class="match-type">Doubles</div>
                                    <div class="match-date">${date}</div>
                                </div>
                                ${editBtn}
                            </div>
                            ${doublesLocationDisplay}
                            <div class="match-result">
                                <span class="match-winner">${winner}</span>
                                <span class="match-def">def.</span>
                                <span class="match-loser">${loser}</span>
                            </div>
                            ${setsDisplay ? `<div class="match-sets">${setsDisplay}</div>` : ''}
                        </div>
                    `;
                } else if (match.match_type === 'canadian') {
                    // Sort players by score to show ranking
                    const players = [
                        { name: match.player1, score: match.score_player1 },
                        { name: match.player2, score: match.score_player2 },
                        { name: match.player3, score: match.score_player3 }
                    ].sort((a, b) => b.score - a.score);

                    const locationDisplay = match.location ? `<div class="match-location">ðŸ“ ${match.location}</div>` : '';
                    return `
                        <div class="match-item match-item-ratfactor">
                            <div class="match-header">
                                <div class="match-header-left">
                                    <div class="match-type">Rat Factor</div>
                                    <div class="match-date">${date}</div>
                                </div>
                                ${editBtn}
                            </div>
                            ${locationDisplay}
                            <div class="ratfactor-scores">
                                <div class="ratfactor-player first">
                                    <span class="ratfactor-rank">1st</span>
                                    <span class="ratfactor-name">${players[0].name}</span>
                                    <span class="ratfactor-score">${players[0].score}</span>
                                </div>
                                <div class="ratfactor-player second">
                                    <span class="ratfactor-rank">2nd</span>
                                    <span class="ratfactor-name">${players[1].name}</span>
                                    <span class="ratfactor-score">${players[1].score}</span>
                                </div>
                                <div class="ratfactor-player third">
                                    <span class="ratfactor-rank">3rd</span>
                                    <span class="ratfactor-name">${players[2].name}</span>
                                    <span class="ratfactor-score">${players[2].score}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }).join('');

        }

        // Render insights
        function renderInsights() {
            const container = document.getElementById('insights');
            const insights = [];
            const currentYear = new Date().getFullYear();

            // Filter matches by type
            const singlesMatches = matches.filter(m => m.match_type === 'singles');
            const doublesMatches = matches.filter(m => m.match_type === 'doubles');
            const canadianMatches = matches.filter(m => m.match_type === 'canadian');

            // This year's matches
            const singlesThisYear = singlesMatches.filter(m => new Date(m.created_at).getFullYear() === currentYear);
            const doublesThisYear = doublesMatches.filter(m => new Date(m.created_at).getFullYear() === currentYear);

            // ========== DOUBLES INSIGHTS ==========

            // Track doubles team records this year
            const doublesTeamRecords = {};
            doublesThisYear.forEach(match => {
                const team1 = [match.player1, match.player2].sort().join(' & ');
                const team2 = [match.player3, match.player4].sort().join(' & ');
                const team1Won = match.winner1 === match.player1 || match.winner1 === match.player2;

                if (!doublesTeamRecords[team1]) doublesTeamRecords[team1] = { wins: 0, losses: 0 };
                if (!doublesTeamRecords[team2]) doublesTeamRecords[team2] = { wins: 0, losses: 0 };

                if (team1Won) {
                    doublesTeamRecords[team1].wins++;
                    doublesTeamRecords[team2].losses++;
                } else {
                    doublesTeamRecords[team2].wins++;
                    doublesTeamRecords[team1].losses++;
                }
            });

            // Find unbeaten doubles teams this year
            Object.entries(doublesTeamRecords).forEach(([team, record]) => {
                if (record.wins >= 1 && record.losses === 0) {
                    insights.push({
                        type: 'doubles',
                        priority: 10,
                        text: `ðŸ† ${team} are unbeaten this year in doubles (${record.wins}-0)`
                    });
                }
            });

            // Best doubles team this year
            const bestDoublesTeam = Object.entries(doublesTeamRecords)
                .filter(([_, r]) => r.wins + r.losses >= 2)
                .sort((a, b) => (b[1].wins - b[1].losses) - (a[1].wins - a[1].losses))[0];
            if (bestDoublesTeam && bestDoublesTeam[1].wins > bestDoublesTeam[1].losses) {
                insights.push({
                    type: 'stat',
                    priority: 5,
                    text: `ðŸ‘¥ ${bestDoublesTeam[0]} lead doubles this year: ${bestDoublesTeam[1].wins}-${bestDoublesTeam[1].losses}`
                });
            }

            // ========== DOUBLES CHEMISTRY ==========
            // Track each player's win rate with each partner
            if (doublesMatches.length >= 3) {
                const playerPartnerStats = {};
                PLAYERS.forEach(p => playerPartnerStats[p] = {});

                doublesMatches.forEach(match => {
                    const team1 = [match.player1, match.player2];
                    const team2 = [match.player3, match.player4];
                    const team1Won = match.winner1 === match.player1 || match.winner1 === match.player2;

                    // Track stats for team 1 players
                    team1.forEach(player => {
                        const partner = team1.find(p => p !== player);
                        if (!playerPartnerStats[player][partner]) {
                            playerPartnerStats[player][partner] = { wins: 0, losses: 0 };
                        }
                        if (team1Won) {
                            playerPartnerStats[player][partner].wins++;
                        } else {
                            playerPartnerStats[player][partner].losses++;
                        }
                    });

                    // Track stats for team 2 players
                    team2.forEach(player => {
                        const partner = team2.find(p => p !== player);
                        if (!playerPartnerStats[player][partner]) {
                            playerPartnerStats[player][partner] = { wins: 0, losses: 0 };
                        }
                        if (!team1Won) {
                            playerPartnerStats[player][partner].wins++;
                        } else {
                            playerPartnerStats[player][partner].losses++;
                        }
                    });
                });

                // Find best chemistry (player with highest win rate with a specific partner, min 2 matches)
                let bestChemistry = null;
                PLAYERS.forEach(player => {
                    Object.entries(playerPartnerStats[player]).forEach(([partner, stats]) => {
                        const total = stats.wins + stats.losses;
                        if (total >= 2) {
                            const winRate = stats.wins / total;
                            if (!bestChemistry || winRate > bestChemistry.winRate ||
                                (winRate === bestChemistry.winRate && stats.wins > bestChemistry.wins)) {
                                bestChemistry = {
                                    player,
                                    partner,
                                    wins: stats.wins,
                                    losses: stats.losses,
                                    winRate
                                };
                            }
                        }
                    });
                });

                if (bestChemistry && bestChemistry.winRate >= 0.6 && bestChemistry.wins >= 2) {
                    insights.push({
                        type: 'doubles',
                        priority: 6,
                        text: `ðŸ¤ ${bestChemistry.player} & ${bestChemistry.partner} have great chemistry: ${bestChemistry.wins}-${bestChemistry.losses} together`
                    });
                }

                // ========== COMMON LOSING DENOMINATOR ==========
                // Find who is most often on the losing team in doubles
                const doublesLosses = {};
                PLAYERS.forEach(p => doublesLosses[p] = { losses: 0, total: 0 });

                doublesMatches.forEach(match => {
                    const team1 = [match.player1, match.player2];
                    const team2 = [match.player3, match.player4];
                    const team1Won = match.winner1 === match.player1 || match.winner1 === match.player2;
                    const losingTeam = team1Won ? team2 : team1;
                    const winningTeam = team1Won ? team1 : team2;

                    // Track losses and total matches for each player
                    losingTeam.forEach(player => {
                        if (player) {
                            doublesLosses[player].losses++;
                            doublesLosses[player].total++;
                        }
                    });
                    winningTeam.forEach(player => {
                        if (player) {
                            doublesLosses[player].total++;
                        }
                    });
                });

                // Find player with highest loss rate (min 4 doubles matches)
                let worstDenominator = null;
                PLAYERS.forEach(player => {
                    const stats = doublesLosses[player];
                    if (stats.total >= 4) {
                        const lossRate = stats.losses / stats.total;
                        if (!worstDenominator || lossRate > worstDenominator.lossRate ||
                            (lossRate === worstDenominator.lossRate && stats.losses > worstDenominator.losses)) {
                            worstDenominator = {
                                player,
                                losses: stats.losses,
                                total: stats.total,
                                lossRate
                            };
                        }
                    }
                });

                // Only show if loss rate is notable (> 55%)
                if (worstDenominator && worstDenominator.lossRate > 0.55) {
                    const lossPercent = Math.round(worstDenominator.lossRate * 100);
                    insights.push({
                        type: 'cold',
                        priority: 7,
                        text: `ðŸª¨ ${worstDenominator.player} is the common losing denominator in doubles (${lossPercent}% loss rate)`
                    });
                }
            }

            // ========== SINGLES STREAKS ==========

            // Calculate current winning/losing streaks for each player
            const playerStreaks = {};
            PLAYERS.forEach(p => playerStreaks[p] = { type: null, count: 0 });

            // Go through matches chronologically (newest first) to find current streaks
            singlesMatches.forEach(match => {
                [match.player1, match.player2].forEach(player => {
                    if (!playerStreaks[player].type) {
                        const won = match.winner1 === player;
                        playerStreaks[player].type = won ? 'win' : 'loss';
                        playerStreaks[player].count = 1;
                    } else if (
                        (playerStreaks[player].type === 'win' && match.winner1 === player) ||
                        (playerStreaks[player].type === 'loss' && match.winner1 !== player)
                    ) {
                        playerStreaks[player].count++;
                    }
                });
            });

            // Report notable streaks (2+ matches)
            Object.entries(playerStreaks).forEach(([player, streak]) => {
                if (streak.count >= 2) {
                    if (streak.type === 'win') {
                        insights.push({
                            type: 'streak',
                            priority: streak.count >= 3 ? 8 : 5,
                            text: `ðŸ”¥ ${player} has won ${streak.count} singles matches in a row!`
                        });
                    } else if (streak.count >= 3) {
                        insights.push({
                            type: 'cold',
                            priority: 6,
                            text: `â„ï¸ ${player} is on a ${streak.count}-match losing streak in singles`
                        });
                    }
                }
            });

            // ========== HEAD TO HEAD RECORDS ==========

            const h2h = {};
            singlesMatches.forEach(match => {
                const key = [match.player1, match.player2].sort().join('_');
                if (!h2h[key]) h2h[key] = { matches: [], players: [match.player1, match.player2].sort() };
                h2h[key].matches.push(match);
            });

            Object.values(h2h).forEach(record => {
                const [p1, p2] = record.players;
                const p1Wins = record.matches.filter(m => m.winner1 === p1).length;
                const p2Wins = record.matches.length - p1Wins;

                // "Never beaten" - one player has 0 wins with multiple matches
                if (record.matches.length >= 2) {
                    if (p1Wins === 0) {
                        insights.push({
                            type: 'dominance',
                            priority: 9,
                            text: `ðŸ’€ ${p1} has never beaten ${p2} in singles (0-${p2Wins})`
                        });
                    } else if (p2Wins === 0) {
                        insights.push({
                            type: 'dominance',
                            priority: 9,
                            text: `ðŸ’€ ${p2} has never beaten ${p1} in singles (0-${p1Wins})`
                        });
                    }
                }

                // H2H dominance (70%+ win rate with 5+ matches)
                if (record.matches.length >= 5) {
                    const dominant = p1Wins > p2Wins ? p1 : p2;
                    const dominated = p1Wins > p2Wins ? p2 : p1;
                    const dominantWins = Math.max(p1Wins, p2Wins);
                    const dominatedWins = Math.min(p1Wins, p2Wins);
                    const ratio = dominantWins / record.matches.length;
                    if (ratio >= 0.7) {
                        insights.push({
                            type: 'stat',
                            priority: 4,
                            text: `ðŸ“Š ${dominant} dominates ${dominated} in singles: ${dominantWins}-${dominatedWins}`
                        });
                    }
                }

                // Recent H2H streak (last 3+ matches against same opponent)
                if (record.matches.length >= 3) {
                    const recentWinner = record.matches[0].winner1;
                    let streak = 0;
                    for (const match of record.matches) {
                        if (match.winner1 === recentWinner) streak++;
                        else break;
                    }
                    if (streak >= 3) {
                        const opponent = recentWinner === p1 ? p2 : p1;
                        insights.push({
                            type: 'streak',
                            priority: 7,
                            text: `ðŸŽ¯ ${recentWinner} has won the last ${streak} matches against ${opponent}`
                        });
                    }
                }
            });

            // ========== RAT FACTOR INSIGHTS ==========

            if (canadianMatches.length >= 3) {
                // Track wins (1st place finishes)
                const ratFactorWins = {};
                PLAYERS.forEach(p => ratFactorWins[p] = 0);

                canadianMatches.forEach(match => {
                    const players = [
                        { name: match.player1, score: match.score_player1 },
                        { name: match.player2, score: match.score_player2 },
                        { name: match.player3, score: match.score_player3 }
                    ].sort((a, b) => b.score - a.score);
                    if (players[0].name) ratFactorWins[players[0].name]++;
                });

                // Rat Factor king
                const ratKing = Object.entries(ratFactorWins).sort((a, b) => b[1] - a[1])[0];
                if (ratKing[1] >= 3) {
                    insights.push({
                        type: 'stat',
                        priority: 5,
                        text: `ðŸ€ ${ratKing[0]} is the Rat Factor king with ${ratKing[1]} wins`
                    });
                }

                // Recent form
                const recentScores = {};
                PLAYERS.forEach(p => recentScores[p] = []);

                canadianMatches.slice(0, 5).forEach(match => {
                    if (match.player1) recentScores[match.player1].push(match.score_player1);
                    if (match.player2) recentScores[match.player2].push(match.score_player2);
                    if (match.player3) recentScores[match.player3].push(match.score_player3);
                });

                PLAYERS.forEach(player => {
                    const scores = recentScores[player];
                    if (scores.length >= 3) {
                        const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
                        if (avg >= 9) {
                            insights.push({
                                type: 'streak',
                                priority: 6,
                                text: `ðŸ“ˆ ${player} is on fire in Rat Factor! Avg ${avg.toFixed(1)} pts recently`
                            });
                        } else if (avg <= 4) {
                            insights.push({
                                type: 'cold',
                                priority: 3,
                                text: `ðŸ“‰ ${player} is struggling in Rat Factor (avg ${avg.toFixed(1)} pts)`
                            });
                        }
                    }
                });

                // Clutch player - wins close Rat Factor games (winner within 2 points of 2nd place)
                const clutchWins = {};
                PLAYERS.forEach(p => clutchWins[p] = 0);

                canadianMatches.forEach(match => {
                    const players = [
                        { name: match.player1, score: match.score_player1 },
                        { name: match.player2, score: match.score_player2 },
                        { name: match.player3, score: match.score_player3 }
                    ].sort((a, b) => b.score - a.score);

                    // Close game = 1st and 2nd place within 2 points
                    const margin = players[0].score - players[1].score;
                    if (margin <= 2 && players[0].name) {
                        clutchWins[players[0].name]++;
                    }
                });

                const clutchLeader = Object.entries(clutchWins).sort((a, b) => b[1] - a[1])[0];
                if (clutchLeader[1] >= 2) {
                    insights.push({
                        type: 'streak',
                        priority: 7,
                        text: `ðŸŽ¯ ${clutchLeader[0]} is clutch! ${clutchLeader[1]} wins in close Rat Factor games`
                    });
                }
            }

            // ========== OVERALL STATS ==========

            // Singles win leader this year
            if (singlesThisYear.length > 0) {
                const winCountsThisYear = {};
                PLAYERS.forEach(p => winCountsThisYear[p] = 0);
                singlesThisYear.forEach(m => {
                    if (m.winner1) winCountsThisYear[m.winner1]++;
                });
                const topWinner = Object.entries(winCountsThisYear).sort((a, b) => b[1] - a[1])[0];
                if (topWinner[1] >= 1) {
                    insights.push({
                        type: 'stat',
                        priority: topWinner[1] >= 3 ? 5 : 3,
                        text: `ðŸ‘‘ ${topWinner[0]} leads ${currentYear} singles with ${topWinner[1]} win${topWinner[1] > 1 ? 's' : ''}`
                    });
                }
            }

            // Most active player
            const matchCounts = {};
            PLAYERS.forEach(p => matchCounts[p] = 0);
            matches.forEach(m => {
                if (m.player1) matchCounts[m.player1]++;
                if (m.player2) matchCounts[m.player2]++;
                if (m.player3) matchCounts[m.player3]++;
                if (m.player4) matchCounts[m.player4]++;
            });
            const sortedByMatches = Object.entries(matchCounts).sort((a, b) => b[1] - a[1]);
            const mostActive = sortedByMatches[0];
            const secondMostActive = sortedByMatches[1];
            // Only show if there's a clear leader (no tie for first)
            if (mostActive[1] >= 3 && mostActive[1] > secondMostActive[1]) {
                insights.push({
                    type: 'stat',
                    priority: 2,
                    text: `ðŸŽ¾ ${mostActive[0]} has played the most matches: ${mostActive[1]} total`
                });
            }

            // Total matches played
            if (matches.length > 0) {
                insights.push({
                    type: 'stat',
                    priority: 1,
                    text: `ðŸ“Š ${matches.length} total matches logged`
                });
            }

            // ========== RENDER ==========

            if (insights.length === 0) {
                container.innerHTML = '<div class="empty-state">Play more matches to unlock insights!</div>';
                return;
            }

            // Sort by priority and take top insights
            insights.sort((a, b) => (b.priority || 0) - (a.priority || 0));

            // Helper to format insight text with highlighted player names
            function formatInsight(text) {
                // Extract emoji from start
                const emojiMatch = text.match(/^(\p{Emoji})\s*/u);
                const emoji = emojiMatch ? emojiMatch[1] : 'ðŸ“Š';
                const textWithoutEmoji = emojiMatch ? text.slice(emojiMatch[0].length) : text;

                // Highlight player names
                let formatted = textWithoutEmoji;
                PLAYERS.forEach(player => {
                    formatted = formatted.replace(new RegExp(`\\b${player}\\b`, 'g'), `<strong>${player}</strong>`);
                });

                // Also highlight team pairs like "Ed & Tom"
                formatted = formatted.replace(/(\w+)\s*&amp;\s*(\w+)/g, '<strong>$1 & $2</strong>');
                formatted = formatted.replace(/(\w+)\s*&\s*(\w+)/g, '<strong>$1 & $2</strong>');

                return { emoji, text: formatted };
            }

            container.innerHTML = insights.slice(0, 6).map(insight => {
                const { emoji, text } = formatInsight(insight.text);
                return `
                    <div class="insight-item ${insight.type}">
                        <span class="insight-emoji">${emoji}</span>
                        <span class="insight-text">${text}</span>
                    </div>
                `;
            }).join('');
        }

        // H2H comprehensive view
        function renderH2H() {
            const container = document.getElementById('h2hGrid');
            const singlesMatches = matches.filter(m => m.match_type === 'singles');

            if (singlesMatches.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸŽ¾</div>No singles matches recorded yet</div>';
                return;
            }

            // Group matches by year
            const matchesByYear = {};
            singlesMatches.forEach(match => {
                const year = new Date(match.created_at).getFullYear();
                if (!matchesByYear[year]) {
                    matchesByYear[year] = [];
                }
                matchesByYear[year].push(match);
            });

            // Sort years descending (newest first)
            const years = Object.keys(matchesByYear).sort((a, b) => b - a);

            // Generate all unique player combinations
            const matchups = [];
            for (let i = 0; i < PLAYERS.length; i++) {
                for (let j = i + 1; j < PLAYERS.length; j++) {
                    matchups.push([PLAYERS[i], PLAYERS[j]]);
                }
            }

            const yearSections = years.map(year => {
                const yearMatches = matchesByYear[year];

                const matchupHTML = matchups.map(([p1, p2]) => {
                    const h2hMatches = yearMatches.filter(m =>
                        (m.player1 === p1 && m.player2 === p2) || (m.player1 === p2 && m.player2 === p1)
                    );

                    if (h2hMatches.length === 0) {
                        return `
                            <div class="h2h-matchup">
                                <div class="h2h-players">
                                    <span class="h2h-player">${p1}</span>
                                    <span class="h2h-vs">VS</span>
                                    <span class="h2h-player">${p2}</span>
                                </div>
                                <div class="h2h-empty">No matches</div>
                            </div>
                        `;
                    }

                    const p1Wins = h2hMatches.filter(m => m.winner1 === p1).length;
                    const p2Wins = h2hMatches.length - p1Wins;

                    // Generate match details with scores
                    const matchDetails = h2hMatches
                        .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                        .map(match => {
                            const winner = match.winner1;
                            const winnerIsP1 = match.winner1 === match.player1;

                            // Parse set scores
                            let scoresDisplay = '';
                            if (match.sets) {
                                try {
                                    const sets = JSON.parse(match.sets);
                                    scoresDisplay = sets.map(s => {
                                        const winnerScore = winnerIsP1 ? s.p1 : s.p2;
                                        const loserScore = winnerIsP1 ? s.p2 : s.p1;
                                        let scoreStr = `${winnerScore}-${loserScore}`;
                                        if (s.tb1 !== undefined && s.tb2 !== undefined) {
                                            const winnerTB = winnerIsP1 ? s.tb1 : s.tb2;
                                            const loserTB = winnerIsP1 ? s.tb2 : s.tb1;
                                            scoreStr += `(${winnerTB}-${loserTB})`;
                                        } else if (s.tiebreak !== undefined) {
                                            const loserTB = s.tiebreak;
                                            const winnerTB = loserTB >= 5 ? loserTB + 2 : 7;
                                            scoreStr += `(${winnerTB}-${loserTB})`;
                                        }
                                        return scoreStr;
                                    }).join(' ');
                                } catch (e) {}
                            }

                            const matchDate = new Date(match.created_at).toLocaleDateString('en-AU', { day: 'numeric', month: 'short' });

                            return `
                                <div class="h2h-match-detail">
                                    <span class="h2h-match-winner">${winner}</span>
                                    <span class="h2h-match-scores">${scoresDisplay || '-'}</span>
                                    <span class="h2h-match-date">${matchDate}</span>
                                </div>
                            `;
                        }).join('');

                    return `
                        <div class="h2h-matchup">
                            <div class="h2h-players">
                                <span class="h2h-player">${p1}</span>
                                <span class="h2h-vs">VS</span>
                                <span class="h2h-player">${p2}</span>
                            </div>
                            <div class="h2h-score">
                                <span class="h2h-score-number">${p1Wins}</span>
                                <span class="h2h-score-separator">-</span>
                                <span class="h2h-score-number">${p2Wins}</span>
                            </div>
                            <div class="h2h-matches">${h2hMatches.length} ${h2hMatches.length === 1 ? 'match' : 'matches'}</div>
                            <div class="h2h-match-list">${matchDetails}</div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="h2h-year-section">
                        <div class="h2h-year-title">${year}</div>
                        <div class="h2h-grid">${matchupHTML}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = yearSections;
        }

        // Toast notification
        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Edit Match Modal Functions
        let editMatchPlayers = { player1: '', player2: '' };

        function openEditModal(matchData) {
            document.getElementById('editMatchId').value = matchData.id;
            document.getElementById('editMatchType').value = matchData.matchType;
            document.getElementById('editLocation').value = matchData.location || '';

            const singlesSection = document.getElementById('editSinglesSection');
            const setsContainer = document.getElementById('editSinglesSetsContainer');

            if (matchData.matchType === 'singles') {
                singlesSection.style.display = 'block';
                editMatchPlayers = { player1: matchData.player1, player2: matchData.player2 };

                // Parse existing sets or create empty one
                let sets = [];
                if (matchData.sets) {
                    try {
                        sets = JSON.parse(matchData.sets);
                    } catch (e) {
                        sets = [];
                    }
                }

                // If no sets, add one empty set
                if (sets.length === 0) {
                    sets = [{ p1: '', p2: '' }];
                }

                // Render sets
                setsContainer.innerHTML = sets.map((set, index) => {
                    const isTiebreak = (set.p1 === 7 && set.p2 === 6) || (set.p1 === 6 && set.p2 === 7) || (set.p1 === 6 && set.p2 === 6);
                    const tb1Val = set.tb1 !== undefined ? set.tb1 : '';
                    const tb2Val = set.tb2 !== undefined ? set.tb2 : '';
                    return `
                        <div class="set-row" data-set="${index + 1}">
                            <span class="set-label">Set ${index + 1}</span>
                            <input type="number" class="set-score-input" data-player="1" min="0" value="${set.p1 || ''}" placeholder="0" onchange="checkEditSinglesTiebreak(this)">
                            <span class="set-separator">-</span>
                            <input type="number" class="set-score-input" data-player="2" min="0" value="${set.p2 || ''}" placeholder="0" onchange="checkEditSinglesTiebreak(this)">
                            <div class="tiebreak-group ${isTiebreak ? 'visible' : ''}">
                                <span class="tiebreak-label">(</span>
                                <input type="number" class="tiebreak-input" data-tb="1" min="0" value="${tb1Val}" placeholder="0" style="width:35px;">
                                <span class="tiebreak-label">-</span>
                                <input type="number" class="tiebreak-input" data-tb="2" min="0" value="${tb2Val}" placeholder="0" style="width:35px;">
                                <span class="tiebreak-label">)</span>
                            </div>
                            <button class="set-remove-btn" onclick="removeEditSinglesSet(this)" style="visibility: ${sets.length === 1 ? 'hidden' : 'visible'};">Ã—</button>
                        </div>
                    `;
                }).join('');
            } else {
                singlesSection.style.display = 'none';
                setsContainer.innerHTML = '';
            }

            document.getElementById('editModal').classList.add('show');
        }

        function addEditSinglesSet() {
            const container = document.getElementById('editSinglesSetsContainer');
            const setRows = container.querySelectorAll('.set-row');
            const newSetNum = setRows.length + 1;

            if (newSetNum > 5) {
                showToast('Maximum 5 sets allowed', true);
                return;
            }

            const newRow = document.createElement('div');
            newRow.className = 'set-row';
            newRow.dataset.set = newSetNum;
            newRow.innerHTML = `
                <span class="set-label">Set ${newSetNum}</span>
                <input type="number" class="set-score-input" data-player="1" min="0" placeholder="0" onchange="checkEditSinglesTiebreak(this)">
                <span class="set-separator">-</span>
                <input type="number" class="set-score-input" data-player="2" min="0" placeholder="0" onchange="checkEditSinglesTiebreak(this)">
                <div class="tiebreak-group">
                    <span class="tiebreak-label">(</span>
                    <input type="number" class="tiebreak-input" data-tb="1" min="0" placeholder="0" style="width:35px;">
                    <span class="tiebreak-label">-</span>
                    <input type="number" class="tiebreak-input" data-tb="2" min="0" placeholder="0" style="width:35px;">
                    <span class="tiebreak-label">)</span>
                </div>
                <button class="set-remove-btn" onclick="removeEditSinglesSet(this)">Ã—</button>
            `;
            container.appendChild(newRow);
            updateEditSinglesSetRemoveButtons();
        }

        function removeEditSinglesSet(btn) {
            const row = btn.closest('.set-row');
            row.remove();

            const container = document.getElementById('editSinglesSetsContainer');
            const setRows = container.querySelectorAll('.set-row');
            setRows.forEach((row, index) => {
                row.dataset.set = index + 1;
                row.querySelector('.set-label').textContent = `Set ${index + 1}`;
            });
            updateEditSinglesSetRemoveButtons();
        }

        function updateEditSinglesSetRemoveButtons() {
            const container = document.getElementById('editSinglesSetsContainer');
            const setRows = container.querySelectorAll('.set-row');
            setRows.forEach((row) => {
                const removeBtn = row.querySelector('.set-remove-btn');
                removeBtn.style.visibility = setRows.length === 1 ? 'hidden' : 'visible';
            });
        }

        function checkEditSinglesTiebreak(input) {
            const row = input.closest('.set-row');
            const p1Score = parseInt(row.querySelector('.set-score-input[data-player="1"]').value) || 0;
            const p2Score = parseInt(row.querySelector('.set-score-input[data-player="2"]').value) || 0;
            const tiebreakGroup = row.querySelector('.tiebreak-group');

            // Show tiebreak input if score is 6-6, 7-6, or 6-7
            if ((p1Score === 6 && p2Score === 6) || (p1Score === 7 && p2Score === 6) || (p1Score === 6 && p2Score === 7)) {
                tiebreakGroup.classList.add('visible');
            } else {
                tiebreakGroup.classList.remove('visible');
                tiebreakGroup.querySelector('.tiebreak-input').value = '';
            }
        }

        function closeEditModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('editModal').classList.remove('show');
        }

        async function saveMatchEdit() {
            const matchId = document.getElementById('editMatchId').value;
            const matchType = document.getElementById('editMatchType').value;
            const location = document.getElementById('editLocation').value.trim() || null;

            // Convert to number if it's a numeric ID
            const idValue = isNaN(matchId) ? matchId : parseInt(matchId);

            const updateData = { location: location };

            // Handle singles sets
            if (matchType === 'singles') {
                const setRows = document.querySelectorAll('#editSinglesSetsContainer .set-row');
                const sets = [];
                let p1SetsWon = 0;
                let p2SetsWon = 0;

                for (const row of setRows) {
                    let p1Score = parseInt(row.querySelector('.set-score-input[data-player="1"]').value);
                    let p2Score = parseInt(row.querySelector('.set-score-input[data-player="2"]').value);

                    if (isNaN(p1Score) || isNaN(p2Score)) {
                        showToast('Please enter scores for all sets', true);
                        return;
                    }

                    const setData = { p1: p1Score, p2: p2Score };

                    // Check for tiebreak (6-6, 7-6, or 6-7)
                    if ((p1Score === 6 && p2Score === 6) || (p1Score === 7 && p2Score === 6) || (p1Score === 6 && p2Score === 7)) {
                        const tb1Input = row.querySelector('.tiebreak-input[data-tb="1"]');
                        const tb2Input = row.querySelector('.tiebreak-input[data-tb="2"]');
                        const tb1Score = parseInt(tb1Input.value);
                        const tb2Score = parseInt(tb2Input.value);

                        if (!isNaN(tb1Score) && !isNaN(tb2Score) && (tb1Score > 0 || tb2Score > 0)) {
                            setData.tb1 = tb1Score;
                            setData.tb2 = tb2Score;
                            setData.tiebreak = Math.min(tb1Score, tb2Score);

                            // If 6-6, auto-convert to 7-6 based on tiebreak winner
                            if (p1Score === 6 && p2Score === 6) {
                                if (tb1Score > tb2Score) {
                                    setData.p1 = 7;
                                    p1Score = 7;
                                } else {
                                    setData.p2 = 7;
                                    p2Score = 7;
                                }
                            }
                        }
                    }

                    sets.push(setData);

                    if (p1Score > p2Score) p1SetsWon++;
                    else if (p2Score > p1Score) p2SetsWon++;
                }

                if (p1SetsWon === p2SetsWon) {
                    showToast('Match cannot be tied - add another set', true);
                    return;
                }

                const winner = p1SetsWon > p2SetsWon ? editMatchPlayers.player1 : editMatchPlayers.player2;
                updateData.sets = JSON.stringify(sets);
                updateData.winner1 = winner;
            }

            try {
                const { error } = await db
                    .from('matches')
                    .update(updateData)
                    .eq('id', idValue);

                if (error) throw error;

                showToast('Match updated!');
                closeEditModal();
                await loadMatches();
            } catch (err) {
                console.error('Error updating match:', err);
                showToast('Error updating match', true);
            }
        }

        // Fighter Select Functions
        function openFighterSelect() {
            const overlay = document.getElementById('fighterSelect');
            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
            updateFighterStats();
        }

        function closeFighterSelect() {
            const overlay = document.getElementById('fighterSelect');
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }

        function updateFighterStats() {
            const singlesMatches = matches.filter(m => m.match_type === 'singles');

            // Get 2026 Rat Factor matches for RF score
            const currentYear = new Date().getFullYear();
            const canadianMatches = matches.filter(m =>
                m.match_type === 'canadian' &&
                new Date(m.created_at).getFullYear() === currentYear
            );

            // Calculate RF championship scores (best 10 results)
            const rfScores = {};
            const pointsMap = { 0: 3, 1: 1, 2: 0 };

            PLAYERS.forEach(player => {
                const playerResults = [];
                canadianMatches.forEach(match => {
                    const players = [
                        { name: match.player1, score: match.score_player1 },
                        { name: match.player2, score: match.score_player2 },
                        { name: match.player3, score: match.score_player3 }
                    ].sort((a, b) => b.score - a.score);

                    const position = players.findIndex(p => p.name === player);
                    if (position !== -1) {
                        playerResults.push(pointsMap[position]);
                    }
                });

                // Sort descending and take best 10
                playerResults.sort((a, b) => b - a);
                rfScores[player] = playerResults.slice(0, 10).reduce((sum, pts) => sum + pts, 0);
            });

            PLAYERS.forEach(player => {
                const wins = singlesMatches.filter(m => m.winner1 === player).length;
                const losses = singlesMatches.filter(m =>
                    (m.player1 === player || m.player2 === player) && m.winner1 !== player
                ).length;

                const playerLower = player.toLowerCase();
                const winsEl = document.getElementById(`${playerLower}-wins`);
                const lossesEl = document.getElementById(`${playerLower}-losses`);
                const rfEl = document.getElementById(`${playerLower}-rf`);

                if (winsEl) winsEl.textContent = wins;
                if (lossesEl) lossesEl.textContent = losses;
                if (rfEl) rfEl.textContent = rfScores[player];
            });
        }

        // Close fighter select with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeFighterSelect();
                closeFighterCard(e);
            }
        });

        // Fighter card data
        const fighterData = {
            Rick: {
                title: 'THE ANGLER',
                image: 'rick images/angler.png',
                strengths: [
                    'The angel of angles',
                    'Can be tender and gentle at the net'
                ],
                weaknesses: [
                    'Prone to clinical grade SHS'
                ]
            },
            Ed: {
                title: 'KINTAMANI',
                image: 'ed images/gein.png',
                strengths: [
                    'Runs like a wounded bull',
                    'Heavy topspin western FH grip'
                ],
                weaknesses: [
                    'High risk net clearance approach'
                ]
            },
            Tom: {
                title: 'DR. DEATH',
                image: 'tom images/drdeath.png',
                strengths: [
                    'First serve in points won >90%',
                    'Versatile all court player'
                ],
                weaknesses: [
                    'Horny for the ESPN highlights reel',
                    'Can be volatile'
                ]
            },
            Jethro: {
                title: 'DIESEL',
                image: 'jethro images/diesel.png',
                strengths: [
                    'Mr missionary'
                ],
                weaknesses: [
                    'Slow speed in all domains'
                ]
            }
        };

        function openFighterCard(player) {
            const data = fighterData[player];
            if (!data) return;

            const cardInner = document.getElementById('fighterCardInner');

            // Reset flip state
            cardInner.classList.remove('flipped');

            // Populate the front of the card
            document.getElementById('enlargedFighterImgFront').src = data.image;
            document.getElementById('enlargedFighterImgFront').alt = player;
            document.getElementById('enlargedFighterNameFront').textContent = player.toUpperCase();
            document.getElementById('enlargedFighterTitleFront').textContent = data.title;

            // Populate the back of the card
            document.getElementById('enlargedFighterImg').src = data.image;
            document.getElementById('enlargedFighterImg').alt = player;
            document.getElementById('enlargedFighterName').textContent = player.toUpperCase();
            document.getElementById('enlargedFighterTitle').textContent = data.title;

            // Strengths
            const strengthsHtml = data.strengths.map(s =>
                `<div class="fighter-trait-item">â€¢ ${s}</div>`
            ).join('') || '<div class="fighter-trait-item">â€¢ None listed</div>';
            document.getElementById('enlargedFighterStrengths').innerHTML = strengthsHtml;

            // Weaknesses
            const weaknessesHtml = data.weaknesses.map(w =>
                `<div class="fighter-trait-item">â€¢ ${w}</div>`
            ).join('') || '<div class="fighter-trait-item">â€¢ None listed</div>';
            document.getElementById('enlargedFighterWeaknesses').innerHTML = weaknessesHtml;

            // Calculate auto stats
            const statsHtml = calculateFighterStats(player);
            document.getElementById('enlargedFighterStats').innerHTML = statsHtml;

            // Show external matches button only for Jethro
            const externalBtn = document.getElementById('externalMatchesBtn');
            externalBtn.style.display = player === 'Jethro' ? 'block' : 'none';

            // Show overlay
            const overlay = document.getElementById('fighterCardOverlay');
            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';

            // Flip card after a short delay
            setTimeout(() => {
                cardInner.classList.add('flipped');
            }, 300);
        }

        function closeFighterCard(e) {
            if (e) e.stopPropagation();
            const overlay = document.getElementById('fighterCardOverlay');
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }

        function calculateFighterStats(player) {
            const stats = [];

            // Singles record
            const singlesMatches = matches.filter(m => m.match_type === 'singles');
            const singlesWins = singlesMatches.filter(m => m.winner1 === player).length;
            const singlesLosses = singlesMatches.filter(m =>
                (m.player1 === player || m.player2 === player) && m.winner1 !== player
            ).length;
            if (singlesWins + singlesLosses > 0) {
                const winPct = Math.round((singlesWins / (singlesWins + singlesLosses)) * 100);
                stats.push(`Singles: ${singlesWins}W-${singlesLosses}L (${winPct}%)`);
            }

            // RF Championship score (best 10 results)
            const currentYear = new Date().getFullYear();
            const canadianMatches = matches.filter(m =>
                m.match_type === 'canadian' &&
                new Date(m.created_at).getFullYear() === currentYear
            );

            const pointsMap = { 0: 3, 1: 1, 2: 0 };
            let rfWins = 0;
            let rfPlayed = 0;
            const rfResults = [];

            canadianMatches.forEach(match => {
                const players = [
                    { name: match.player1, score: match.score_player1 },
                    { name: match.player2, score: match.score_player2 },
                    { name: match.player3, score: match.score_player3 }
                ].sort((a, b) => b.score - a.score);

                const position = players.findIndex(p => p.name === player);
                if (position !== -1) {
                    rfPlayed++;
                    if (position === 0) rfWins++;
                    rfResults.push(pointsMap[position]);
                }
            });

            if (rfPlayed > 0) {
                // Calculate best 10 score
                rfResults.sort((a, b) => b - a);
                const rfScore = rfResults.slice(0, 10).reduce((sum, pts) => sum + pts, 0);
                stats.push(`RF Score: ${rfScore} pts (${rfPlayed} played, ${rfWins} wins)`);
            }

            // Best opponent (who they beat most)
            const winsAgainst = {};
            singlesMatches.forEach(m => {
                if (m.winner1 === player) {
                    const opponent = m.player1 === player ? m.player2 : m.player1;
                    winsAgainst[opponent] = (winsAgainst[opponent] || 0) + 1;
                }
            });
            const bestOpponent = Object.entries(winsAgainst).sort((a, b) => b[1] - a[1])[0];
            if (bestOpponent && bestOpponent[1] >= 2) {
                stats.push(`Best vs: ${bestOpponent[0]} (${bestOpponent[1]} wins)`);
            }

            // Worst opponent (who beats them most)
            const lossesAgainst = {};
            singlesMatches.forEach(m => {
                if ((m.player1 === player || m.player2 === player) && m.winner1 !== player) {
                    lossesAgainst[m.winner1] = (lossesAgainst[m.winner1] || 0) + 1;
                }
            });
            const worstOpponent = Object.entries(lossesAgainst).sort((a, b) => b[1] - a[1])[0];
            if (worstOpponent && worstOpponent[1] >= 2) {
                stats.push(`Struggles vs: ${worstOpponent[0]} (${worstOpponent[1]} losses)`);
            }

            return stats.map(s => `<div class="fighter-trait-item">â€¢ ${s}</div>`).join('')
                || '<div class="fighter-trait-item">â€¢ No stats yet</div>';
        }

        // External matches data (Jethro vs non-Rat Factor players)
        // matchType options: 'full' (regulation sets), 'tiebreaks' (tiebreaks only), 'halfcourt' (half court)
        const externalMatches = [
            // Placeholder data - replace with real data
            { opponent: 'Sample Player', date: '2026-01-15', score: '6-4, 6-2', won: true, matchType: 'full' },
            { opponent: 'Sample Player', date: '2026-01-10', score: '4-6, 7-5, 6-3', won: true, matchType: 'full' },
            { opponent: 'Another Player', date: '2026-01-05', score: '7-6(5), 3-6, 4-6', won: false, matchType: 'full' },
            { opponent: 'Another Player', date: '2025-12-20', score: '7-4, 7-5', won: true, matchType: 'tiebreaks' },
        ];

        function openExternalMatches(e) {
            e.stopPropagation();

            // Calculate summary per opponent
            const opponents = {};
            externalMatches.forEach(m => {
                if (!opponents[m.opponent]) {
                    opponents[m.opponent] = { wins: 0, losses: 0 };
                }
                if (m.won) {
                    opponents[m.opponent].wins++;
                } else {
                    opponents[m.opponent].losses++;
                }
            });

            // Render summary
            const summaryHtml = Object.entries(opponents).map(([name, record]) => {
                const isNegative = record.losses > record.wins;
                return `
                    <div class="external-opponent-summary">
                        <div class="external-opponent-name">${name}</div>
                        <div class="external-opponent-record ${isNegative ? 'negative' : ''}">${record.wins}W - ${record.losses}L</div>
                    </div>
                `;
            }).join('');
            document.getElementById('externalMatchesSummary').innerHTML = summaryHtml;

            // Render match list (sorted by date, newest first)
            const sortedMatches = [...externalMatches].sort((a, b) => new Date(b.date) - new Date(a.date));
            const matchesHtml = sortedMatches.map(m => {
                const dateStr = new Date(m.date).toLocaleDateString('en-AU', { day: 'numeric', month: 'short', year: 'numeric' });
                const typeLabels = {
                    'full': '',
                    'tiebreaks': 'Tiebreaks only',
                    'halfcourt': 'Half court'
                };
                const typeLabel = typeLabels[m.matchType] || '';
                return `
                    <div class="external-match-item">
                        <div class="external-match-header">
                            <span class="external-match-opponent">vs ${m.opponent}</span>
                            <span class="external-match-date">${dateStr}</span>
                        </div>
                        <div class="external-match-score">
                            ${m.score}
                            <span class="external-match-result ${m.won ? 'win' : 'loss'}">${m.won ? 'W' : 'L'}</span>
                        </div>
                        ${typeLabel ? `<div class="external-match-type">${typeLabel}</div>` : ''}
                    </div>
                `;
            }).join('');
            document.getElementById('externalMatchesList').innerHTML = matchesHtml;

            // Show modal
            document.getElementById('externalMatchesModal').classList.add('active');
        }

        function closeExternalMatches(e) {
            if (e.target === e.currentTarget || e.target.classList.contains('external-matches-close')) {
                document.getElementById('externalMatchesModal').classList.remove('active');
            }
        }

        // Interactive Matchup Wheel Functions
        const wheelState = {
            selectedPlayer: null,
            otherPlayers: [],
            rotation: 0,
            velocity: 0,
            isSpinning: false,
            isDragging: false,
            lastAngle: 0,
            lastTime: 0,
            velocityHistory: [],
            canvas: null,
            ctx: null,
            centerX: 0,
            centerY: 0,
            radius: 0,
            playerImages: {},
            lastPegIndex: 0,
            audioContext: null
        };

        const NUM_PEGS = 12; // 4 copies of each of 3 players
        const WHEEL_COLORS = ['#FF6B9D', '#44FF44', '#FFD93D'];
        const FRICTION = 0.985;
        const MIN_VELOCITY = 0.1;
        const MIN_SPIN_VELOCITY = 3;

        // Initialize audio context for tick sounds
        function initAudio() {
            if (!wheelState.audioContext) {
                wheelState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        // Play tick sound using Web Audio API
        function playTickSound() {
            if (!wheelState.audioContext) return;

            const ctx = wheelState.audioContext;
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);

            // Create a short, sharp tick sound
            oscillator.frequency.setValueAtTime(800, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.03);
            oscillator.type = 'square';

            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);

            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.05);
        }

        // Trigger flipper bounce animation
        function triggerFlipperBounce() {
            const pointer = document.querySelector('.wheel-pointer');
            if (pointer) {
                pointer.classList.remove('tick');
                // Force reflow to restart animation
                void pointer.offsetWidth;
                pointer.classList.add('tick');
            }
        }

        // Get current peg index based on rotation
        function getCurrentPegIndex() {
            const segmentAngle = (2 * Math.PI) / NUM_PEGS;
            let normalizedRotation = wheelState.rotation % (2 * Math.PI);
            if (normalizedRotation < 0) normalizedRotation += 2 * Math.PI;

            // Pointer is at angle 0 (right side)
            const relativeAngle = (2 * Math.PI - normalizedRotation) % (2 * Math.PI);
            return Math.floor(relativeAngle / segmentAngle) % NUM_PEGS;
        }

        // Player image paths
        const PLAYER_WHEEL_IMAGES = {
            'Rick': 'rick images/rickwheel.jpeg',
            'Ed': 'ed images/gein.png',
            'Tom': 'tom images/drdeath.png',
            'Jethro': 'jethro images/IMG_1066.JPG'
        };

        // Initialize player selection buttons
        function initWheelPlayerSelect() {
            const container = document.getElementById('wheelPlayerSelect');
            container.innerHTML = PLAYERS.map(player => `
                <button class="wheel-player-btn" onclick="selectWheelPlayer('${player}')">${player}</button>
            `).join('');
        }

        // Handle player selection
        function selectWheelPlayer(player) {
            wheelState.selectedPlayer = player;
            wheelState.otherPlayers = PLAYERS.filter(p => p !== player);
            document.getElementById('wheelSelectedName').textContent = player;
            showWheelPhase(2);

            // Preload images for the other players
            loadWheelImages().then(() => {
                initWheel();
            });
        }

        // Preload player images
        function loadWheelImages() {
            const promises = wheelState.otherPlayers.map(player => {
                return new Promise((resolve) => {
                    if (wheelState.playerImages[player]) {
                        resolve();
                        return;
                    }
                    const img = new Image();
                    img.onload = () => {
                        wheelState.playerImages[player] = img;
                        resolve();
                    };
                    img.onerror = () => {
                        wheelState.playerImages[player] = null;
                        resolve();
                    };
                    img.src = PLAYER_WHEEL_IMAGES[player];
                });
            });
            return Promise.all(promises);
        }

        // Show specific phase
        function showWheelPhase(phase) {
            document.querySelectorAll('.wheel-phase').forEach(el => el.classList.remove('active'));
            document.getElementById(`wheelPhase${phase}`).classList.add('active');

            if (phase === 2) {
                document.getElementById('wheelInstruction').textContent = 'Swipe or drag to spin!';
                document.getElementById('wheelInstruction').style.animation = 'pulse 2s ease-in-out infinite';
            }
        }

        // Initialize wheel canvas
        function initWheel() {
            const canvas = document.getElementById('wheelCanvas');
            const container = document.getElementById('wheelContainer');

            // High-DPI support
            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            const size = Math.min(rect.width, 320);

            canvas.width = size * dpr;
            canvas.height = size * dpr;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';

            wheelState.canvas = canvas;
            wheelState.ctx = canvas.getContext('2d');
            wheelState.ctx.scale(dpr, dpr);

            wheelState.centerX = size / 2;
            wheelState.centerY = size / 2;
            wheelState.radius = (size / 2) - 10;
            wheelState.rotation = 0;
            wheelState.velocity = 0;
            wheelState.isSpinning = false;

            drawWheel();
            setupWheelEvents();
        }

        // Draw the wheel with game show style pegs
        function drawWheel() {
            const { ctx, centerX, centerY, radius, rotation, otherPlayers, playerImages } = wheelState;
            const segmentAngle = (2 * Math.PI) / NUM_PEGS;

            ctx.clearRect(0, 0, wheelState.canvas.width, wheelState.canvas.height);

            // Draw 12 segments (4 copies of each player)
            for (let i = 0; i < NUM_PEGS; i++) {
                const startAngle = rotation + (i * segmentAngle);
                const endAngle = startAngle + segmentAngle;
                const playerIndex = i % 3;
                const player = otherPlayers[playerIndex];
                const img = playerImages[player];

                // Draw segment background
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = WHEEL_COLORS[playerIndex];
                ctx.fill();

                // Draw player image in every 4th segment (centered positions)
                if (i % 4 === 1 && img) {
                    ctx.save();
                    // Clip to segment
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    ctx.closePath();
                    ctx.clip();

                    // Calculate image position - center it in the segment
                    const midAngle = startAngle + segmentAngle / 2;
                    const imgDistance = radius * 0.6;
                    const imgX = centerX + Math.cos(midAngle) * imgDistance;
                    const imgY = centerY + Math.sin(midAngle) * imgDistance;

                    // Draw circular image
                    const imgRadius = radius * 0.18;
                    ctx.beginPath();
                    ctx.arc(imgX, imgY, imgRadius, 0, 2 * Math.PI);
                    ctx.closePath();
                    ctx.clip();

                    // Draw image scaled to cover the circle
                    const aspectRatio = img.width / img.height;
                    let drawWidth, drawHeight;
                    if (aspectRatio > 1) {
                        drawHeight = imgRadius * 2;
                        drawWidth = drawHeight * aspectRatio;
                    } else {
                        drawWidth = imgRadius * 2;
                        drawHeight = drawWidth / aspectRatio;
                    }
                    ctx.drawImage(
                        img,
                        imgX - drawWidth / 2,
                        imgY - drawHeight / 2,
                        drawWidth,
                        drawHeight
                    );
                    ctx.restore();
                }

                // Draw segment border
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw player name in the segment
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + segmentAngle / 2);
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#000';
                ctx.font = 'bold 11px "Bebas Neue", sans-serif';
                ctx.fillText(player.toUpperCase(), radius - 6, 0);
                ctx.restore();
            }

            // Draw pegs at segment boundaries
            for (let i = 0; i < NUM_PEGS; i++) {
                const pegAngle = rotation + (i * segmentAngle);
                const pegX = centerX + Math.cos(pegAngle) * (radius - 8);
                const pegY = centerY + Math.sin(pegAngle) * (radius - 8);

                // Draw peg (metallic look)
                ctx.beginPath();
                ctx.arc(pegX, pegY, 6, 0, 2 * Math.PI);
                const gradient = ctx.createRadialGradient(pegX - 2, pegY - 2, 0, pegX, pegY, 6);
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.3, '#cccccc');
                gradient.addColorStop(1, '#666666');
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw outer rim
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Draw center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 25, 0, 2 * Math.PI);
            ctx.fillStyle = '#1a1a2e';
            ctx.fill();
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // Get unified event position (touch or mouse)
        function getEventPosition(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        // Calculate angle from center of wheel
        function getAngleFromCenter(x, y) {
            const rect = wheelState.canvas.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            return Math.atan2(y - centerY, x - centerX);
        }

        // Setup wheel event listeners
        function setupWheelEvents() {
            const canvas = wheelState.canvas;

            // Remove old listeners by replacing element
            const newCanvas = canvas.cloneNode(true);
            canvas.parentNode.replaceChild(newCanvas, canvas);
            wheelState.canvas = newCanvas;
            wheelState.ctx = newCanvas.getContext('2d');

            const dpr = window.devicePixelRatio || 1;
            wheelState.ctx.scale(dpr, dpr);

            // Touch events
            newCanvas.addEventListener('touchstart', handleDragStart, { passive: false });
            newCanvas.addEventListener('touchmove', handleDragMove, { passive: false });
            newCanvas.addEventListener('touchend', handleDragEnd);
            newCanvas.addEventListener('touchcancel', handleDragEnd);

            // Mouse events
            newCanvas.addEventListener('mousedown', handleDragStart);
            newCanvas.addEventListener('mousemove', handleDragMove);
            newCanvas.addEventListener('mouseup', handleDragEnd);
            newCanvas.addEventListener('mouseleave', handleDragEnd);

            drawWheel();
        }

        function handleDragStart(e) {
            if (wheelState.isSpinning) return;

            e.preventDefault();

            // Initialize audio on first user interaction
            initAudio();

            const pos = getEventPosition(e);

            wheelState.isDragging = true;
            wheelState.lastAngle = getAngleFromCenter(pos.x, pos.y);
            wheelState.lastTime = performance.now();
            wheelState.velocityHistory = [];
            wheelState.lastPegIndex = getCurrentPegIndex();
        }

        function handleDragMove(e) {
            if (!wheelState.isDragging || wheelState.isSpinning) return;

            e.preventDefault();
            const pos = getEventPosition(e);
            const currentAngle = getAngleFromCenter(pos.x, pos.y);
            const currentTime = performance.now();

            // Calculate angle delta
            let deltaAngle = currentAngle - wheelState.lastAngle;

            // Handle wrap-around
            if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
            if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;

            // Update rotation
            wheelState.rotation += deltaAngle;

            // Track velocity (degrees per ms)
            const deltaTime = currentTime - wheelState.lastTime;
            if (deltaTime > 0) {
                const velocity = (deltaAngle * 180 / Math.PI) / deltaTime;
                wheelState.velocityHistory.push(velocity);
                if (wheelState.velocityHistory.length > 5) {
                    wheelState.velocityHistory.shift();
                }
            }

            wheelState.lastAngle = currentAngle;
            wheelState.lastTime = currentTime;

            drawWheel();
        }

        function handleDragEnd(e) {
            if (!wheelState.isDragging) return;

            wheelState.isDragging = false;

            // Calculate average velocity
            if (wheelState.velocityHistory.length > 0) {
                const avgVelocity = wheelState.velocityHistory.reduce((a, b) => a + b, 0) / wheelState.velocityHistory.length;

                // Convert to degrees per frame (assuming 60fps)
                wheelState.velocity = avgVelocity * 16.67;

                // Only spin if velocity exceeds threshold
                if (Math.abs(wheelState.velocity) >= MIN_SPIN_VELOCITY) {
                    wheelState.isSpinning = true;
                    document.getElementById('wheelInstruction').textContent = 'Spinning...';
                    document.getElementById('wheelInstruction').style.animation = 'none';
                    animateWheel();
                }
            }
        }

        // Animate wheel spin with friction
        function animateWheel() {
            if (!wheelState.isSpinning) return;

            // Apply friction
            wheelState.velocity *= FRICTION;

            // Update rotation (convert degrees to radians)
            wheelState.rotation += wheelState.velocity * Math.PI / 180;

            // Check for peg crossing and trigger tick
            const currentPegIndex = getCurrentPegIndex();
            if (currentPegIndex !== wheelState.lastPegIndex) {
                wheelState.lastPegIndex = currentPegIndex;
                playTickSound();
                triggerFlipperBounce();
            }

            drawWheel();

            // Check if wheel has stopped
            if (Math.abs(wheelState.velocity) < MIN_VELOCITY) {
                wheelState.isSpinning = false;
                wheelState.velocity = 0;
                determineWinner();
            } else {
                requestAnimationFrame(animateWheel);
            }
        }

        // Determine which segment the pointer landed on
        function determineWinner() {
            // With 12 segments (4 copies of each player), we need to find which player
            // the current segment belongs to
            const currentPegIndex = getCurrentPegIndex();

            // Each player appears 4 times, at indices: 0,3,6,9 / 1,4,7,10 / 2,5,8,11
            // So playerIndex = pegIndex % 3
            const playerIndex = currentPegIndex % 3;

            const partner = wheelState.otherPlayers[playerIndex];
            const opponents = wheelState.otherPlayers.filter(p => p !== partner);

            displayMatchupResult({
                team1: [wheelState.selectedPlayer, partner],
                team2: opponents
            });

            showWheelPhase(3);
        }

        // Display the matchup result
        function displayMatchupResult(matchup) {
            document.getElementById('team1Player1').textContent = matchup.team1[0];
            document.getElementById('team1Player1').style.animationDelay = '0s';
            document.getElementById('team1Player2').textContent = matchup.team1[1];
            document.getElementById('team1Player2').style.animationDelay = '0.2s';
            document.getElementById('team2Player1').textContent = matchup.team2[0];
            document.getElementById('team2Player1').style.animationDelay = '0.4s';
            document.getElementById('team2Player2').textContent = matchup.team2[1];
            document.getElementById('team2Player2').style.animationDelay = '0.6s';
        }

        // Reset wheel for another spin (same player)
        function resetWheelForSpin() {
            showWheelPhase(2);
            wheelState.rotation = Math.random() * 2 * Math.PI; // Random starting position
            wheelState.velocity = 0;
            wheelState.isSpinning = false;
            drawWheel();
        }

        // Initialize player selection on page load
        document.addEventListener('DOMContentLoaded', initWheelPlayerSelect);
    </script>
</body>
</html>
