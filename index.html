<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a2e">
    <title>Rat Factor üéæ</title>
    <link rel="manifest" href="manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Press+Start+2P&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root {
            --bg-dark: #1a1a2e;
            --bg-card: #16213e;
            --accent-yellow: #f0e130;
            --accent-green: #00ff88;
            --accent-pink: #ff6b9d;
            --text-light: #eaeaea;
            --text-muted: #8892a0;
            --border-subtle: rgba(255,255,255,0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Space Mono', monospace;
            background: var(--bg-dark);
            color: var(--text-light);
            min-height: 100vh;
            min-height: 100dvh;
            overflow-x: hidden;
        }

        /* Noise texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0.03;
            pointer-events: none;
            z-index: 1000;
        }

        .app-container {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            padding-bottom: 100px;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 30px 0 20px;
            position: relative;
        }

        .header h1 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 4rem;
            letter-spacing: 4px;
            color: var(--accent-yellow);
            text-shadow: 3px 3px 0 var(--accent-pink);
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .header .subtitle {
            font-size: 0.7rem;
            color: var(--text-muted);
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .header .rat {
            font-size: 2rem;
            margin: 10px 0 0;
            display: inline-block;
            animation: ratScurry 2s ease-in-out;
            animation-fill-mode: forwards;
        }

        @keyframes ratScurry {
            0% {
                transform: translateX(-100vw) scaleX(-1) rotate(0deg);
            }
            5% {
                transform: translateX(-90vw) scaleX(-1) rotate(-5deg);
            }
            10% {
                transform: translateX(-80vw) scaleX(-1) rotate(5deg);
            }
            15% {
                transform: translateX(-70vw) scaleX(-1) rotate(-5deg);
            }
            20% {
                transform: translateX(-60vw) scaleX(-1) rotate(5deg);
            }
            25% {
                transform: translateX(-50vw) scaleX(-1) rotate(-5deg);
            }
            30% {
                transform: translateX(-40vw) scaleX(-1) rotate(5deg);
            }
            35% {
                transform: translateX(-30vw) scaleX(-1) rotate(-5deg);
            }
            40% {
                transform: translateX(-20vw) scaleX(-1) rotate(5deg);
            }
            45% {
                transform: translateX(20px) scaleX(-1) rotate(0deg);
            }
            50% {
                transform: translateX(20px) scaleX(-1) rotate(0deg);
            }
            55% {
                transform: translateX(20px) scaleX(1) rotate(0deg);
            }
            60% {
                transform: translateX(15px) scaleX(1) rotate(-5deg);
            }
            65% {
                transform: translateX(10px) scaleX(1) rotate(5deg);
            }
            70% {
                transform: translateX(-5px) scaleX(1) rotate(-5deg);
            }
            75% {
                transform: translateX(0px) scaleX(1) rotate(5deg);
            }
            80% {
                transform: translateX(3px) scaleX(1) rotate(-2deg);
            }
            90% {
                transform: translateX(-1px) scaleX(1) rotate(2deg);
            }
            100% {
                transform: translateX(0) scaleX(1) rotate(0deg);
            }
        }

        /* Navigation tabs */
        .nav-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 25px;
            overflow-x: auto;
            padding-bottom: 5px;
        }

        .nav-tab {
            flex: 1;
            min-width: fit-content;
            padding: 12px 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-muted);
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .nav-tab:hover {
            border-color: var(--accent-yellow);
        }

        .nav-tab.active {
            background: var(--accent-yellow);
            color: var(--bg-dark);
            border-color: var(--accent-yellow);
            font-weight: 700;
        }

        /* Sections */
        .section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .card-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 2px;
            color: var(--accent-green);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        /* Leaderboard - WSL Championship style */
        #leaderboard {
            display: flex;
            flex-direction: column;
            overflow-x: auto;
        }

        .leaderboard-table {
            width: 100%;
            min-width: fit-content;
        }

        .leaderboard-header {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 2px solid var(--accent-yellow);
            font-size: 0.65rem;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-transform: uppercase;
            font-weight: 700;
        }

        .leaderboard-header-rank {
            width: 50px;
            text-align: center;
            flex-shrink: 0;
        }
        .leaderboard-header-name {
            width: 140px;
            padding-left: 5px;
            flex-shrink: 0;
        }
        .leaderboard-header-event {
            width: 45px;
            text-align: center;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .leaderboard-header-event .event-icon {
            font-size: 0.7rem;
        }
        .leaderboard-header-event .event-location {
            font-size: 0.5rem;
            color: var(--text-muted);
            opacity: 0.7;
            max-width: 45px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .leaderboard-header-pts {
            width: 55px;
            text-align: center;
            flex-shrink: 0;
            margin-left: auto;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-subtle);
            transition: all 0.2s ease;
        }

        .leaderboard-item:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-rank {
            width: 50px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.6rem;
            text-align: center;
            color: var(--text-muted);
            line-height: 1;
            flex-shrink: 0;
        }


        .leaderboard-player {
            width: 140px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .leaderboard-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--card-bg);
            border: 2px solid var(--border-subtle);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.75rem;
            color: var(--text-muted);
            overflow: hidden;
            flex-shrink: 0;
        }

        .leaderboard-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .leaderboard-name {
            font-weight: 700;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .leaderboard-events {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }

        .leaderboard-event-score {
            width: 45px;
            text-align: center;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            flex-shrink: 0;
        }

        .leaderboard-event-score.not-counting {
            text-decoration: line-through;
            color: var(--text-muted);
            opacity: 0.5;
        }

        .leaderboard-event-score.first-place {
            color: #ffd700;
            font-weight: 700;
        }

        .leaderboard-event-score.second-place {
            color: #c0c0c0;
        }

        .leaderboard-event-score.third-place {
            color: var(--text-muted);
        }

        .leaderboard-event-score.no-play {
            color: var(--text-muted);
            opacity: 0.3;
        }

        .leaderboard-total {
            width: 55px;
            text-align: center;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.6rem;
            color: var(--accent-yellow);
            line-height: 1;
            flex-shrink: 0;
            margin-left: auto;
        }

        /* Leader row highlight */
        .leaderboard-item.leader {
            background: linear-gradient(90deg, rgba(240, 225, 48, 0.12) 0%, rgba(240, 225, 48, 0.03) 100%);
            border-left: 3px solid var(--accent-yellow);
        }

        .leaderboard-item.leader .leaderboard-name {
            color: var(--accent-yellow);
        }

        /* Championship footer */
        .championship-subtitle {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 15px;
            letter-spacing: 1px;
            text-align: center;
        }

        /* Points gap from leader */
        .points-gap {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            font-weight: 400;
            color: var(--accent-pink);
            background: rgba(255, 107, 157, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* Form elements */
        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-muted);
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .form-select, .form-input {
            width: 100%;
            padding: 14px;
            background: var(--bg-dark);
            border: 2px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-light);
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            transition: border-color 0.2s ease;
            appearance: none;
        }

        .form-select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%238892a0' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 45px;
        }

        .form-select:focus, .form-input:focus {
            outline: none;
            border-color: var(--accent-yellow);
        }

        .form-select option {
            background: var(--bg-dark);
        }

        /* Player selection grid */
        .player-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .player-toggle {
            padding: 15px;
            background: var(--bg-dark);
            border: 2px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-light);
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .player-toggle:hover {
            border-color: var(--accent-green);
        }

        .player-toggle.selected {
            background: var(--accent-green);
            color: var(--bg-dark);
            border-color: var(--accent-green);
            font-weight: 700;
        }

        .player-toggle.winner {
            background: var(--accent-yellow);
            color: var(--bg-dark);
            border-color: var(--accent-yellow);
        }

        /* Score inputs */
        .score-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .score-input-group {
            text-align: center;
        }

        .score-input-group label {
            display: block;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .score-input {
            width: 100%;
            padding: 12px;
            background: var(--bg-dark);
            border: 2px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--accent-yellow);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            text-align: center;
        }

        .score-input:focus {
            outline: none;
            border-color: var(--accent-yellow);
        }

        /* Submit button */
        .btn-submit {
            width: 100%;
            padding: 18px;
            background: var(--accent-yellow);
            border: none;
            border-radius: 8px;
            color: var(--bg-dark);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .btn-submit:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(240, 225, 48, 0.3);
        }

        .btn-submit:active {
            transform: translateY(0);
        }

        .btn-submit:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Match history */
        .match-item {
            background: var(--bg-dark);
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 3px solid var(--accent-green);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .match-item:hover {
            transform: translateX(4px);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
        }

        .match-item:last-child {
            margin-bottom: 0;
        }

        .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .match-type {
            font-size: 0.65rem;
            color: var(--bg-dark);
            background: var(--accent-pink);
            letter-spacing: 1px;
            text-transform: uppercase;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 4px;
        }

        .match-players {
            font-size: 0.95rem;
            margin-bottom: 5px;
        }

        .match-winner {
            color: var(--accent-green);
            font-weight: 700;
        }

        .match-result {
            font-size: 1rem;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .match-def {
            color: var(--text-muted);
            font-size: 0.7rem;
            font-style: italic;
            padding: 0 6px;
        }

        .match-loser {
            color: var(--text-muted);
        }

        .match-sets {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            color: var(--accent-yellow);
            letter-spacing: 3px;
            margin-bottom: 8px;
        }

        .match-date {
            font-size: 0.7rem;
            color: var(--text-muted);
            opacity: 0.7;
        }

        /* Rat Factor match display */
        .match-item-ratfactor {
            border-left-color: var(--accent-yellow);
        }

        .ratfactor-scores {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .ratfactor-player {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.03);
        }

        .ratfactor-player.first {
            background: rgba(240, 225, 48, 0.15);
        }

        .ratfactor-rank {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.9rem;
            color: var(--text-muted);
            width: 30px;
        }

        .ratfactor-player.first .ratfactor-rank {
            color: var(--accent-yellow);
        }

        .ratfactor-name {
            flex: 1;
            font-weight: 600;
        }

        .ratfactor-player.first .ratfactor-name {
            color: var(--accent-green);
        }

        .ratfactor-score {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            color: var(--accent-yellow);
            min-width: 25px;
            text-align: right;
        }

        /* Head to head */
        .h2h-year-section {
            margin-bottom: 30px;
        }

        .h2h-year-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 2px;
            color: var(--accent-yellow);
            margin-bottom: 15px;
            text-align: center;
        }

        .h2h-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
        }

        .h2h-matchup {
            background: var(--bg-dark);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            padding: 15px;
            transition: all 0.2s ease;
        }

        .h2h-matchup:hover {
            border-color: var(--accent-yellow);
            transform: translateY(-2px);
        }

        .h2h-players {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .h2h-player {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 1px;
        }

        .h2h-vs {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.9rem;
            color: var(--accent-pink);
        }

        .h2h-score {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .h2h-score-number {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            color: var(--accent-yellow);
        }

        .h2h-score-separator {
            font-size: 1.5rem;
            color: var(--text-muted);
        }

        .h2h-matches {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-align: center;
            letter-spacing: 1px;
        }

        .h2h-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        /* Insights */
        #insights {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .insight-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 16px 18px;
            background: var(--bg-dark);
            border-left: 4px solid var(--accent-green);
            border-radius: 0 10px 10px 0;
            font-size: 0.9rem;
            line-height: 1.6;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .insight-item:hover {
            transform: translateX(4px);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        }

        .insight-emoji {
            font-size: 1.4rem;
            flex-shrink: 0;
            width: 28px;
            text-align: center;
        }

        .insight-text {
            flex: 1;
            color: var(--text-light);
        }

        .insight-text strong {
            color: var(--accent-green);
            font-weight: 700;
        }

        .insight-item.streak {
            border-left-color: var(--accent-pink);
        }

        .insight-item.streak .insight-text strong {
            color: var(--accent-pink);
        }

        .insight-item.doubles {
            border-left-color: var(--accent-yellow);
        }

        .insight-item.doubles .insight-text strong {
            color: var(--accent-yellow);
        }

        .insight-item.dominance {
            border-left-color: #9b59b6;
        }

        .insight-item.dominance .insight-text strong {
            color: #9b59b6;
        }

        .insight-item.cold {
            border-left-color: #3498db;
        }

        .insight-item.cold .insight-text strong {
            color: #3498db;
        }

        .insight-item.stat {
            border-left-color: var(--accent-green);
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--accent-green);
            color: var(--bg-dark);
            padding: 15px 25px;
            border-radius: 8px;
            font-weight: 700;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1001;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.error {
            background: var(--accent-pink);
        }

        /* Edit button */
        .match-edit-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 8px 12px;
            font-size: 1rem;
            opacity: 0.5;
            transition: opacity 0.2s;
            position: relative;
            z-index: 10;
        }
        .match-edit-btn:hover {
            opacity: 1;
            color: var(--accent-yellow);
        }
        .match-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .match-location {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 5px;
        }

        /* Edit Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 25px;
            width: 90%;
            max-width: 400px;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        .modal-overlay.show .modal {
            transform: scale(1);
        }
        .modal-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-yellow);
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }
        .modal-btn-cancel {
            background: var(--border-subtle);
            color: var(--text-primary);
        }
        .modal-btn-save {
            background: var(--accent-yellow);
            color: var(--bg-dark);
        }
        .modal-btn:hover {
            transform: translateY(-2px);
        }

        /* Loading spinner */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        #leaderboard.loading {
            flex-direction: row;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-subtle);
            border-top-color: var(--accent-yellow);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Team display for doubles */
        .team-section {
            margin-bottom: 15px;
        }

        .team-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        /* Canadian doubles specific */
        .canadian-players {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .canadian-player-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-dark);
            border-radius: 8px;
        }

        .canadian-player-name {
            flex: 1;
            font-weight: 700;
        }

        .canadian-player-score {
            width: 60px;
        }

        .canadian-player-score input {
            width: 100%;
            padding: 8px;
            background: transparent;
            border: 2px solid var(--border-subtle);
            border-radius: 6px;
            color: var(--accent-yellow);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            text-align: center;
        }

        .canadian-player-score input:focus {
            outline: none;
            border-color: var(--accent-yellow);
        }

        /* Tennis set inputs */
        #setsContainer {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 10px;
        }

        .set-row {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--bg-dark);
            padding: 10px 12px;
            border-radius: 8px;
        }

        .set-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            min-width: 45px;
        }

        .set-score-input {
            width: 50px;
            padding: 8px;
            background: transparent;
            border: 2px solid var(--border-subtle);
            border-radius: 6px;
            color: var(--accent-yellow);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            text-align: center;
        }

        .set-score-input:focus {
            outline: none;
            border-color: var(--accent-yellow);
        }

        .set-separator {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            color: var(--text-muted);
        }

        .set-remove-btn {
            background: none;
            border: none;
            color: var(--accent-pink);
            font-size: 1.3rem;
            cursor: pointer;
            padding: 0 5px;
            line-height: 1;
        }

        .set-remove-btn:hover {
            color: #ff4777;
        }

        .btn-add-set {
            background: transparent;
            border: 2px dashed var(--border-subtle);
            border-radius: 8px;
            color: var(--text-muted);
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-add-set:hover {
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        /* Fighter Select Button */
        .btn-fighter-select {
            width: 100%;
            padding: 16px 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%);
            border: 2px solid var(--accent-pink);
            border-radius: 8px;
            color: var(--accent-pink);
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255, 107, 157, 0.2);
        }

        .btn-fighter-select:hover {
            background: var(--accent-pink);
            color: var(--bg-dark);
            box-shadow: 0 0 30px rgba(255, 107, 157, 0.5);
            transform: scale(1.02);
        }

        .btn-fighter-select .btn-icon {
            font-size: 1.4rem;
        }

        /* Fighter Select Overlay */
        .fighter-select-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a12 0%, #1a1a2e 50%, #0f0f1a 100%);
            z-index: 2000;
            display: none;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
        }

        .fighter-select-overlay.active {
            display: flex;
        }

        /* Animated background grid */
        .fighter-select-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(rgba(255, 107, 157, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 107, 157, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Scanline effect */
        .fighter-select-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
        }

        .fighter-select-content {
            position: relative;
            z-index: 1;
            width: 100%;
            max-width: 600px;
            padding: 30px 20px;
        }

        .fighter-select-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .fighter-select-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.1rem;
            color: var(--accent-yellow);
            text-shadow:
                0 0 10px var(--accent-yellow),
                0 0 20px var(--accent-yellow),
                0 0 40px var(--accent-yellow),
                3px 3px 0 var(--accent-pink);
            animation: titleFlicker 3s ease-in-out infinite;
            letter-spacing: 2px;
        }

        @keyframes titleFlicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.8; }
            94% { opacity: 1; }
            95% { opacity: 0.9; }
            96% { opacity: 1; }
        }

        .fighter-select-subtitle {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 15px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        /* Fighter Grid */
        .fighter-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .fighter-card {
            position: relative;
            background: linear-gradient(180deg, #16213e 0%, #0f0f1a 100%);
            border: 2px solid var(--border-subtle);
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .fighter-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 107, 157, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .fighter-card:hover {
            transform: translateY(-5px) scale(1.03);
            animation: none;
        }

        /* Player-specific hover glows */
        .fighter-card[data-player="Rick"]:hover {
            border-color: #ff4444;
            box-shadow:
                0 10px 40px rgba(255, 68, 68, 0.4),
                0 0 60px rgba(255, 68, 68, 0.3),
                inset 0 0 30px rgba(255, 68, 68, 0.1);
        }
        .fighter-card[data-player="Ed"]:hover {
            border-color: #44ff44;
            box-shadow:
                0 10px 40px rgba(68, 255, 68, 0.4),
                0 0 60px rgba(68, 255, 68, 0.3),
                inset 0 0 30px rgba(68, 255, 68, 0.1);
        }
        .fighter-card[data-player="Tom"]:hover {
            border-color: #4444ff;
            box-shadow:
                0 10px 40px rgba(68, 68, 255, 0.4),
                0 0 60px rgba(68, 68, 255, 0.3),
                inset 0 0 30px rgba(68, 68, 255, 0.1);
        }
        .fighter-card[data-player="Jethro"]:hover {
            border-color: #ffff44;
            box-shadow:
                0 10px 40px rgba(255, 255, 68, 0.4),
                0 0 60px rgba(255, 255, 68, 0.3),
                inset 0 0 30px rgba(255, 255, 68, 0.1);
        }

        .fighter-card:hover::before {
            opacity: 1;
        }

        .fighter-portrait {
            width: 100%;
            aspect-ratio: 3/4;
            background: linear-gradient(135deg, #2a2a4e 0%, #1a1a2e 100%);
            border-radius: 8px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            position: relative;
            overflow: hidden;
            filter: contrast(1.1) saturate(1.2);
            transition: filter 0.3s ease;
        }

        /* Fighter image styling */
        .fighter-img {
            height: 160%;
            width: auto;
            object-fit: contain;
            object-position: top center;
            position: relative;
            z-index: 1;
            margin-top: 80%;
            animation: fighterWobble 3s cubic-bezier(0.45, 0.05, 0.55, 0.95) infinite;
            filter: drop-shadow(0 0 20px rgba(0,0,0,0.5));
        }

        .fighter-card:nth-child(2) .fighter-img { animation-delay: 0.4s; }
        .fighter-card:nth-child(3) .fighter-img { animation-delay: 0.8s; }
        .fighter-card:nth-child(4) .fighter-img { animation-delay: 1.2s; }

        @keyframes fighterWobble {
            0%, 100% { transform: translateX(0) rotate(0deg); }
            50% { transform: translateX(3px) rotate(0.5deg); }
        }

        /* Bottom vignette */
        .fighter-portrait::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 40%),
                radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.4) 100%);
            pointer-events: none;
            z-index: 1;
        }

        .fighter-card:hover .fighter-portrait {
            filter: contrast(1.2) saturate(1.4) brightness(1.1);
            transform: scale(1.02);
        }

        /* Player-specific colors */
        .fighter-card[data-player="Rick"] .fighter-portrait {
            background:
                radial-gradient(ellipse at 50% 80%, rgba(255, 100, 0, 0.4) 0%, transparent 50%),
                radial-gradient(ellipse at 30% 70%, rgba(255, 50, 0, 0.3) 0%, transparent 40%),
                radial-gradient(ellipse at 70% 70%, rgba(255, 150, 0, 0.3) 0%, transparent 40%),
                linear-gradient(180deg, #1a0a0a 0%, #2d1010 50%, #4a1a0a 100%);
            border-bottom: 3px solid #ff4444;
            animation: rickBackground 3s ease-in-out infinite;
        }

        @keyframes rickBackground {
            0%, 100% {
                background-position: 0% 0%, 0% 0%, 0% 0%, 0% 0%;
            }
            50% {
                background-position: 0% 5%, 5% -5%, -5% -5%, 0% 0%;
            }
        }
        .fighter-card[data-player="Ed"] .fighter-portrait {
            background: linear-gradient(135deg, #1a3d1a 0%, #1a1a2e 100%);
            border-bottom: 3px solid #44ff44;
        }
        .fighter-card[data-player="Tom"] .fighter-portrait {
            background: linear-gradient(135deg, #1a1a3d 0%, #1a1a2e 100%);
            border-bottom: 3px solid #4444ff;
        }
        .fighter-card[data-player="Jethro"] .fighter-portrait {
            background: linear-gradient(135deg, #3d3d1a 0%, #1a1a2e 100%);
            border-bottom: 3px solid #ffff44;
        }

        .fighter-name {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            color: var(--text-light);
            text-align: center;
            letter-spacing: 3px;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .fighter-card:hover .fighter-name {
            color: var(--accent-yellow);
            text-shadow: 0 0 10px var(--accent-yellow);
        }

        .fighter-stats {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 8px;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .fighter-stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .fighter-stat-value {
            color: var(--accent-green);
            font-weight: 700;
        }

        /* Close button */
        .fighter-select-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: 2px solid var(--text-muted);
            color: var(--text-muted);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .fighter-select-close:hover {
            border-color: var(--accent-pink);
            color: var(--accent-pink);
            transform: rotate(90deg);
        }

        /* VS text for when selecting */
        .fighter-vs {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: var(--accent-pink);
            text-align: center;
            margin: 20px 0;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1>RAT FACTOR</h1>
            <p class="subtitle">Lets see it</p>
            <div class="rat">üêÄ</div>
        </header>

        <nav class="nav-tabs">
            <button class="nav-tab active" data-section="home">Home</button>
            <button class="nav-tab" data-section="log">Log Match</button>
            <button class="nav-tab" data-section="history">History</button>
            <button class="nav-tab" data-section="h2h">H2H</button>
        </nav>

        <!-- HOME SECTION -->
        <section id="home" class="section active">
            <div class="card">
                <h2 class="card-title">üêÄ Rat Factor Championship</h2>
                <div id="leaderboard" class="loading">
                    <div class="spinner"></div>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">üí° Insights</h2>
                <div id="insights">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

        </section>

        <!-- LOG MATCH SECTION -->
        <section id="log" class="section">
            <div class="card">
                <h2 class="card-title">üìù Log New Match</h2>
                
                <div class="form-group">
                    <label class="form-label">Match Type</label>
                    <select id="matchType" class="form-select">
                        <option value="">Select type...</option>
                        <option value="singles">Singles (1v1)</option>
                        <option value="doubles">Doubles (2v2)</option>
                        <option value="canadian">Rat Factor (3 players)</option>
                    </select>
                </div>

                <div id="matchForm" style="display: none;"></div>
            </div>
        </section>

        <!-- HISTORY SECTION -->
        <section id="history" class="section">
            <div class="card">
                <h2 class="card-title">üìú Match History</h2>
                <div id="matchHistory">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>
        </section>

        <!-- HEAD TO HEAD SECTION -->
        <section id="h2h" class="section">
            <div class="card">
                <h2 class="card-title">‚öîÔ∏è Head to Head</h2>
                <div id="h2hGrid">
                    <div class="loading"><div class="spinner"></div></div>
                </div>
            </div>

            <button class="btn-fighter-select" onclick="openFighterSelect()">
                <span class="btn-icon">üéÆ</span>
                Fighter Select
            </button>
        </section>
    </div>

    <!-- Fighter Select Overlay -->
    <div id="fighterSelect" class="fighter-select-overlay">
        <button class="fighter-select-close" onclick="closeFighterSelect()">‚úï</button>
        <div class="fighter-select-content">
            <div class="fighter-select-header">
                <h1 class="fighter-select-title">SELECT YOUR FIGHTER</h1>
                <p class="fighter-select-subtitle">Choose wisely</p>
            </div>
            <div class="fighter-grid">
                <div class="fighter-card" data-player="Rick">
                    <div class="fighter-portrait">
                        <img src="rick images/angler.png" alt="Rick" class="fighter-img">
                    </div>
                    <div class="fighter-name">Rick</div>
                    <div class="fighter-stats">
                        <span class="fighter-stat">W: <span class="fighter-stat-value" id="rick-wins">-</span></span>
                        <span class="fighter-stat">L: <span class="fighter-stat-value" id="rick-losses">-</span></span>
                    </div>
                </div>
                <div class="fighter-card" data-player="Ed">
                    <div class="fighter-portrait">üéæ</div>
                    <div class="fighter-name">Ed</div>
                    <div class="fighter-stats">
                        <span class="fighter-stat">W: <span class="fighter-stat-value" id="ed-wins">-</span></span>
                        <span class="fighter-stat">L: <span class="fighter-stat-value" id="ed-losses">-</span></span>
                    </div>
                </div>
                <div class="fighter-card" data-player="Tom">
                    <div class="fighter-portrait">üéæ</div>
                    <div class="fighter-name">Tom</div>
                    <div class="fighter-stats">
                        <span class="fighter-stat">W: <span class="fighter-stat-value" id="tom-wins">-</span></span>
                        <span class="fighter-stat">L: <span class="fighter-stat-value" id="tom-losses">-</span></span>
                    </div>
                </div>
                <div class="fighter-card" data-player="Jethro">
                    <div class="fighter-portrait">üéæ</div>
                    <div class="fighter-name">Jethro</div>
                    <div class="fighter-stats">
                        <span class="fighter-stat">W: <span class="fighter-stat-value" id="jethro-wins">-</span></span>
                        <span class="fighter-stat">L: <span class="fighter-stat-value" id="jethro-losses">-</span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <!-- Edit Match Modal -->
    <div id="editModal" class="modal-overlay" onclick="closeEditModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-title">Edit Match</div>
            <input type="hidden" id="editMatchId">
            <div class="form-group">
                <label class="form-label">Location</label>
                <input type="text" id="editLocation" class="form-input" placeholder="e.g. Tom's Court, The Park">
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" onclick="closeEditModal()">Cancel</button>
                <button class="modal-btn modal-btn-save" onclick="saveMatchEdit()">Save</button>
            </div>
        </div>
    </div>

    <script>
        // Supabase setup
        const SUPABASE_URL = 'https://osbbviimzoqaeyneogtp.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_7LNEQqzEeiCw_giwIWP44g_8M7_cxvz';
        const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        const PLAYERS = ['Rick', 'Ed', 'Tom', 'Jethro'];

        // State
        let matches = [];

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            initNavigation();
            initMatchTypeSelector();
            loadMatches();

            // Global click handler for edit buttons (event delegation)
            document.addEventListener('click', (e) => {
                const editBtn = e.target.closest('.match-edit-btn');
                if (editBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    const matchId = editBtn.dataset.matchId;
                    const location = editBtn.dataset.location || '';
                    openEditModal(matchId, location);
                }
            });
        });

        // Navigation
        function initNavigation() {
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.section).classList.add('active');
                });
            });
        }

        // Match type selector
        function initMatchTypeSelector() {
            document.getElementById('matchType').addEventListener('change', (e) => {
                renderMatchForm(e.target.value);
            });
        }

        // Render match form based on type
        function renderMatchForm(type) {
            const container = document.getElementById('matchForm');
            
            if (!type) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            if (type === 'singles') {
                container.innerHTML = `
                    <div class="form-group">
                        <label class="form-label">Player 1</label>
                        <select id="singlesP1" class="form-select">
                            <option value="">Select player...</option>
                            ${PLAYERS.map(p => `<option value="${p}">${p}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Player 2</label>
                        <select id="singlesP2" class="form-select">
                            <option value="">Select player...</option>
                            ${PLAYERS.map(p => `<option value="${p}">${p}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Winner</label>
                        <select id="singlesWinner" class="form-select">
                            <option value="">Select winner...</option>
                        </select>
                    </div>
                    <button class="btn-submit" onclick="submitSingles()">LOG MATCH</button>
                `;

                // Update winner dropdown when players change
                ['singlesP1', 'singlesP2'].forEach(id => {
                    document.getElementById(id).addEventListener('change', updateSinglesWinnerOptions);
                });
            } else if (type === 'doubles') {
                container.innerHTML = `
                    <div class="team-section">
                        <div class="team-label">TEAM 1</div>
                        <div class="player-grid">
                            ${PLAYERS.map(p => `<button class="player-toggle" data-team="1" data-player="${p}">${p}</button>`).join('')}
                        </div>
                    </div>
                    <div class="team-section">
                        <div class="team-label">TEAM 2</div>
                        <div class="player-grid">
                            ${PLAYERS.map(p => `<button class="player-toggle" data-team="2" data-player="${p}">${p}</button>`).join('')}
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Sets</label>
                        <div id="setsContainer">
                            <div class="set-row" data-set="1">
                                <span class="set-label">Set 1</span>
                                <input type="number" class="set-score-input" data-team="1" min="0" max="7" placeholder="0">
                                <span class="set-separator">-</span>
                                <input type="number" class="set-score-input" data-team="2" min="0" max="7" placeholder="0">
                                <button class="set-remove-btn" onclick="removeSet(this)" style="visibility: hidden;">√ó</button>
                            </div>
                        </div>
                        <button class="btn-add-set" onclick="addSet()">+ Add Set</button>
                    </div>
                    <button class="btn-submit" onclick="submitDoubles()">LOG MATCH</button>
                `;

                // Team selection logic
                document.querySelectorAll('.player-toggle').forEach(btn => {
                    btn.addEventListener('click', handleDoublesPlayerToggle);
                });
            } else if (type === 'canadian') {
                container.innerHTML = `
                    <div class="form-group">
                        <label class="form-label">Select 3 Players</label>
                        <div class="player-grid">
                            ${PLAYERS.map(p => `<button class="player-toggle canadian-toggle" data-player="${p}">${p}</button>`).join('')}
                        </div>
                    </div>
                    <div id="canadianScores" style="display: none;">
                        <div class="form-group">
                            <label class="form-label">Final Scores</label>
                            <div class="canadian-players" id="canadianPlayerScores"></div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Target Score</label>
                            <select id="canadianTarget" class="form-select">
                                <option value="11">First to 11</option>
                                <option value="7">First to 7</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Location (optional)</label>
                            <input type="text" id="canadianLocation" class="form-input" placeholder="e.g. Tom's Court, The Park">
                        </div>
                    </div>
                    <button class="btn-submit" onclick="submitCanadian()">LOG MATCH</button>
                `;

                document.querySelectorAll('.canadian-toggle').forEach(btn => {
                    btn.addEventListener('click', handleCanadianPlayerToggle);
                });
            }
        }

        function updateSinglesWinnerOptions() {
            const p1 = document.getElementById('singlesP1').value;
            const p2 = document.getElementById('singlesP2').value;
            const winnerSelect = document.getElementById('singlesWinner');
            
            winnerSelect.innerHTML = '<option value="">Select winner...</option>';
            if (p1) winnerSelect.innerHTML += `<option value="${p1}">${p1}</option>`;
            if (p2 && p2 !== p1) winnerSelect.innerHTML += `<option value="${p2}">${p2}</option>`;
        }

        function handleDoublesPlayerToggle(e) {
            const btn = e.target;
            const team = btn.dataset.team;
            const player = btn.dataset.player;

            // Check if player is already on the other team
            const otherTeam = team === '1' ? '2' : '1';
            const otherTeamBtn = document.querySelector(`.player-toggle[data-team="${otherTeam}"][data-player="${player}"].selected`);
            if (otherTeamBtn) {
                otherTeamBtn.classList.remove('selected');
            }

            btn.classList.toggle('selected');

            // Limit to 2 per team
            const teamSelected = document.querySelectorAll(`.player-toggle[data-team="${team}"].selected`);
            if (teamSelected.length > 2) {
                teamSelected[0].classList.remove('selected');
            }
        }

        function addSet() {
            const container = document.getElementById('setsContainer');
            const setRows = container.querySelectorAll('.set-row');
            const newSetNum = setRows.length + 1;

            if (newSetNum > 5) {
                showToast('Maximum 5 sets allowed', true);
                return;
            }

            const newRow = document.createElement('div');
            newRow.className = 'set-row';
            newRow.dataset.set = newSetNum;
            newRow.innerHTML = `
                <span class="set-label">Set ${newSetNum}</span>
                <input type="number" class="set-score-input" data-team="1" min="0" max="7" placeholder="0">
                <span class="set-separator">-</span>
                <input type="number" class="set-score-input" data-team="2" min="0" max="7" placeholder="0">
                <button class="set-remove-btn" onclick="removeSet(this)">√ó</button>
            `;
            container.appendChild(newRow);
            updateSetRemoveButtons();
        }

        function removeSet(btn) {
            const row = btn.closest('.set-row');
            row.remove();

            // Renumber remaining sets
            const container = document.getElementById('setsContainer');
            const setRows = container.querySelectorAll('.set-row');
            setRows.forEach((row, index) => {
                row.dataset.set = index + 1;
                row.querySelector('.set-label').textContent = `Set ${index + 1}`;
            });
            updateSetRemoveButtons();
        }

        function updateSetRemoveButtons() {
            const container = document.getElementById('setsContainer');
            const setRows = container.querySelectorAll('.set-row');
            setRows.forEach((row, index) => {
                const removeBtn = row.querySelector('.set-remove-btn');
                // Hide remove button if only one set remains
                removeBtn.style.visibility = setRows.length === 1 ? 'hidden' : 'visible';
            });
        }

        function handleCanadianPlayerToggle(e) {
            const btn = e.target;
            btn.classList.toggle('selected');

            const selected = document.querySelectorAll('.canadian-toggle.selected');
            if (selected.length > 3) {
                selected[0].classList.remove('selected');
            }

            updateCanadianScoresUI();
        }

        function updateCanadianScoresUI() {
            const selected = Array.from(document.querySelectorAll('.canadian-toggle.selected')).map(b => b.dataset.player);
            const scoresContainer = document.getElementById('canadianScores');
            const scoresDiv = document.getElementById('canadianPlayerScores');

            if (selected.length === 3) {
                scoresContainer.style.display = 'block';
                scoresDiv.innerHTML = selected.map(player => `
                    <div class="canadian-player-row">
                        <span class="canadian-player-name">${player}</span>
                        <div class="canadian-player-score">
                            <input type="number" id="score_${player}" min="0" placeholder="0">
                        </div>
                    </div>
                `).join('');
            } else {
                scoresContainer.style.display = 'none';
            }
        }

        // Submit functions
        async function submitSingles() {
            const p1 = document.getElementById('singlesP1').value;
            const p2 = document.getElementById('singlesP2').value;
            const winner = document.getElementById('singlesWinner').value;

            if (!p1 || !p2 || !winner || p1 === p2) {
                showToast('Please fill all fields correctly', true);
                return;
            }

            const match = {
                match_type: 'singles',
                player1: p1,
                player2: p2,
                winner1: winner
            };

            await saveMatch(match);
        }

        async function submitDoubles() {
            const team1 = Array.from(document.querySelectorAll('.player-toggle[data-team="1"].selected')).map(b => b.dataset.player);
            const team2 = Array.from(document.querySelectorAll('.player-toggle[data-team="2"].selected')).map(b => b.dataset.player);

            if (team1.length !== 2 || team2.length !== 2) {
                showToast('Please select 2 players per team', true);
                return;
            }

            // Collect set scores
            const setRows = document.querySelectorAll('.set-row');
            const sets = [];
            let team1SetsWon = 0;
            let team2SetsWon = 0;

            for (const row of setRows) {
                const team1Score = parseInt(row.querySelector('.set-score-input[data-team="1"]').value);
                const team2Score = parseInt(row.querySelector('.set-score-input[data-team="2"]').value);

                if (isNaN(team1Score) || isNaN(team2Score)) {
                    showToast('Please enter scores for all sets', true);
                    return;
                }

                sets.push({ team1: team1Score, team2: team2Score });

                if (team1Score > team2Score) team1SetsWon++;
                else if (team2Score > team1Score) team2SetsWon++;
            }

            if (team1SetsWon === team2SetsWon) {
                showToast('Match cannot be tied - add another set', true);
                return;
            }

            const winners = team1SetsWon > team2SetsWon ? team1 : team2;

            const match = {
                match_type: 'doubles',
                player1: team1[0],
                player2: team1[1],
                player3: team2[0],
                player4: team2[1],
                winner1: winners[0],
                winner2: winners[1],
                sets: JSON.stringify(sets)
            };

            await saveMatch(match);
        }

        async function submitCanadian() {
            const selected = Array.from(document.querySelectorAll('.canadian-toggle.selected')).map(b => b.dataset.player);
            
            if (selected.length !== 3) {
                showToast('Please select exactly 3 players', true);
                return;
            }

            const scores = {};
            let hasScores = true;
            selected.forEach(player => {
                const scoreInput = document.getElementById(`score_${player}`);
                const score = parseInt(scoreInput.value);
                if (isNaN(score)) hasScores = false;
                scores[player] = score;
            });

            if (!hasScores) {
                showToast('Please enter all scores', true);
                return;
            }

            const target = parseInt(document.getElementById('canadianTarget').value);
            const location = document.getElementById('canadianLocation').value.trim() || null;

            const match = {
                match_type: 'canadian',
                player1: selected[0],
                player2: selected[1],
                player3: selected[2],
                score_player1: scores[selected[0]],
                score_player2: scores[selected[1]],
                score_player3: scores[selected[2]],
                target_score: target,
                location: location
            };

            await saveMatch(match);
        }

        async function saveMatch(match) {
            try {
                const { error } = await db.from('matches').insert([match]);
                
                if (error) throw error;

                showToast('Match logged! üéæ');
                document.getElementById('matchType').value = '';
                document.getElementById('matchForm').style.display = 'none';
                loadMatches();
                
                // Switch to home tab
                document.querySelector('.nav-tab[data-section="home"]').click();
            } catch (err) {
                console.error('Error saving match:', err);
                showToast('Error saving match', true);
            }
        }

        // Load matches
        async function loadMatches() {
            try {
                const { data, error } = await db
                    .from('matches')
                    .select('*')
                    .order('created_at', { ascending: false });

                if (error) throw error;

                matches = data || [];
                renderLeaderboard();
                renderHistory();
                renderInsights();
                renderH2H();
            } catch (err) {
                console.error('Error loading matches:', err);
                document.getElementById('leaderboard').innerHTML = '<div class="empty-state">Error loading data</div>';
            }
        }

        // Render leaderboard - WSL Championship style with event columns
        function renderLeaderboard() {
            const container = document.getElementById('leaderboard');
            const currentYear = new Date().getFullYear();
            const canadianMatches = matches.filter(m =>
                m.match_type === 'canadian' &&
                new Date(m.created_at).getFullYear() === currentYear
            ).sort((a, b) => new Date(a.created_at) - new Date(b.created_at)); // Sort chronologically

            if (canadianMatches.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üêÄ</div>No Rat Factor matches yet this year</div>';
                return;
            }

            // Player photos (only Rick has one for now)
            const playerPhotos = {
                'Rick': 'rick.png',
                'Ed': null,
                'Tom': null,
                'Jethro': null
            };

            // Calculate points per event for each player
            // Points: 1st = 3pts, 2nd = 1pt, 3rd = 0pts
            const playerEventResults = {};
            PLAYERS.forEach(p => playerEventResults[p] = []);

            canadianMatches.forEach((match, eventIndex) => {
                const players = [
                    { name: match.player1, score: match.score_player1 || 0 },
                    { name: match.player2, score: match.score_player2 || 0 },
                    { name: match.player3, score: match.score_player3 || 0 }
                ].filter(p => p.name);

                players.sort((a, b) => b.score - a.score);

                // Award points: 1st = 3, 2nd = 1, 3rd = 0
                const pointsMap = { 0: 3, 1: 1, 2: 0 };

                // Initialize all players as not playing this event
                PLAYERS.forEach(p => {
                    playerEventResults[p][eventIndex] = { points: null, position: null };
                });

                players.forEach((player, position) => {
                    if (player.name && playerEventResults[player.name]) {
                        playerEventResults[player.name][eventIndex] = {
                            points: pointsMap[position],
                            position: position + 1
                        };
                    }
                });
            });

            // Calculate championship standings (best 10 results)
            const standings = PLAYERS.map(name => {
                const allResults = playerEventResults[name];
                const playedResults = allResults
                    .map((r, idx) => ({ ...r, eventIndex: idx }))
                    .filter(r => r.points !== null);

                // Sort by points descending to find best 10
                const sortedByPoints = [...playedResults].sort((a, b) => b.points - a.points);
                const best10Indices = new Set(sortedByPoints.slice(0, 10).map(r => r.eventIndex));

                const totalPoints = sortedByPoints.slice(0, 10).reduce((sum, r) => sum + r.points, 0);
                const wins = sortedByPoints.slice(0, 10).filter(r => r.position === 1).length;

                return {
                    name,
                    points: totalPoints,
                    events: playedResults.length,
                    wins,
                    best10Indices,
                    eventResults: allResults
                };
            }).sort((a, b) => {
                if (b.points !== a.points) return b.points - a.points;
                return b.wins - a.wins;
            });

            // Build header with event columns
            const eventHeaders = canadianMatches.map((match, i) => {
                const location = match.location ? `<span class="event-location">${match.location}</span>` : '';
                return `
                    <div class="leaderboard-header-event">
                        <span class="event-icon">üêÄ</span>
                        <span>${i + 1}</span>
                        ${location}
                    </div>
                `;
            }).join('');

            // Build player rows
            const playerRows = standings.map((player, index) => {
                // Calculate rank - players with same points share the same rank
                const rank = standings.findIndex(p => p.points === player.points) + 1;

                const photo = playerPhotos[player.name];
                const avatarContent = photo
                    ? `<img src="${photo}" alt="${player.name}">`
                    : player.name.charAt(0);

                const eventScores = player.eventResults.map((result, eventIndex) => {
                    if (result.points === null) {
                        return `<div class="leaderboard-event-score no-play">-</div>`;
                    }

                    const isCounting = player.best10Indices.has(eventIndex);
                    const positionClass = result.position === 1 ? 'first-place' :
                                         result.position === 2 ? 'second-place' : 'third-place';
                    const countingClass = isCounting ? '' : 'not-counting';

                    return `<div class="leaderboard-event-score ${positionClass} ${countingClass}">${result.points}</div>`;
                }).join('');

                return `
                    <div class="leaderboard-item rank-${rank}${rank === 1 ? ' leader' : ''}">
                        <div class="leaderboard-rank">${rank}</div>
                        <div class="leaderboard-player">
                            <div class="leaderboard-avatar">${avatarContent}</div>
                            <div class="leaderboard-name">${player.name}</div>
                        </div>
                        <div class="leaderboard-events">${eventScores}</div>
                        <div class="leaderboard-total">${player.points}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="leaderboard-table">
                    <div class="leaderboard-header">
                        <div class="leaderboard-header-rank">#</div>
                        <div class="leaderboard-header-name">Name</div>
                        ${eventHeaders}
                        <div class="leaderboard-header-pts">Pts</div>
                    </div>
                    ${playerRows}
                </div>
                <div class="championship-subtitle">${currentYear} SEASON ‚Ä¢ BEST 10 RESULTS COUNT</div>
            `;
        }

        // Render history
        function renderHistory() {
            const container = document.getElementById('matchHistory');

            if (matches.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üìú</div>No matches logged yet</div>';
                return;
            }

            container.innerHTML = matches.slice(0, 20).map(match => {
                const date = new Date(match.created_at).toLocaleDateString('en-AU', {
                    day: 'numeric',
                    month: 'short',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                const editBtn = `<button class="match-edit-btn" data-match-id="${match.id}" data-location="${(match.location || '').replace(/"/g, '&quot;')}">‚úèÔ∏è</button>`;

                if (match.match_type === 'singles') {
                    const winner = match.winner1;
                    const loser = match.winner1 === match.player1 ? match.player2 : match.player1;
                    const singlesLocationDisplay = match.location ? `<div class="match-location">üìç ${match.location}</div>` : '';
                    return `
                        <div class="match-item">
                            <div class="match-header">
                                <div class="match-header-left">
                                    <div class="match-type">Singles</div>
                                    <div class="match-date">${date}</div>
                                </div>
                                ${editBtn}
                            </div>
                            ${singlesLocationDisplay}
                            <div class="match-result">
                                <span class="match-winner">${winner}</span>
                                <span class="match-def">def.</span>
                                <span class="match-loser">${loser}</span>
                            </div>
                        </div>
                    `;
                } else if (match.match_type === 'doubles') {
                    const team1 = `${match.player1} & ${match.player2}`;
                    const team2 = `${match.player3} & ${match.player4}`;
                    const team1Won = match.winner1 === match.player1 || match.winner1 === match.player2;
                    const winner = team1Won ? team1 : team2;
                    const loser = team1Won ? team2 : team1;

                    // Parse sets if available (show from winner's perspective)
                    let setsDisplay = '';
                    if (match.sets) {
                        try {
                            const sets = JSON.parse(match.sets);
                            setsDisplay = sets.map(s => {
                                const winnerScore = team1Won ? s.team1 : s.team2;
                                const loserScore = team1Won ? s.team2 : s.team1;
                                return `${winnerScore}-${loserScore}`;
                            }).join(' ');
                        } catch (e) {
                            setsDisplay = '';
                        }
                    }

                    const doublesLocationDisplay = match.location ? `<div class="match-location">üìç ${match.location}</div>` : '';
                    return `
                        <div class="match-item">
                            <div class="match-header">
                                <div class="match-header-left">
                                    <div class="match-type">Doubles</div>
                                    <div class="match-date">${date}</div>
                                </div>
                                ${editBtn}
                            </div>
                            ${doublesLocationDisplay}
                            <div class="match-result">
                                <span class="match-winner">${winner}</span>
                                <span class="match-def">def.</span>
                                <span class="match-loser">${loser}</span>
                            </div>
                            ${setsDisplay ? `<div class="match-sets">${setsDisplay}</div>` : ''}
                        </div>
                    `;
                } else if (match.match_type === 'canadian') {
                    // Sort players by score to show ranking
                    const players = [
                        { name: match.player1, score: match.score_player1 },
                        { name: match.player2, score: match.score_player2 },
                        { name: match.player3, score: match.score_player3 }
                    ].sort((a, b) => b.score - a.score);

                    const locationDisplay = match.location ? `<div class="match-location">üìç ${match.location}</div>` : '';
                    return `
                        <div class="match-item match-item-ratfactor">
                            <div class="match-header">
                                <div class="match-header-left">
                                    <div class="match-type">Rat Factor</div>
                                    <div class="match-date">${date}</div>
                                </div>
                                ${editBtn}
                            </div>
                            ${locationDisplay}
                            <div class="ratfactor-scores">
                                <div class="ratfactor-player first">
                                    <span class="ratfactor-rank">1st</span>
                                    <span class="ratfactor-name">${players[0].name}</span>
                                    <span class="ratfactor-score">${players[0].score}</span>
                                </div>
                                <div class="ratfactor-player second">
                                    <span class="ratfactor-rank">2nd</span>
                                    <span class="ratfactor-name">${players[1].name}</span>
                                    <span class="ratfactor-score">${players[1].score}</span>
                                </div>
                                <div class="ratfactor-player third">
                                    <span class="ratfactor-rank">3rd</span>
                                    <span class="ratfactor-name">${players[2].name}</span>
                                    <span class="ratfactor-score">${players[2].score}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }).join('');

        }

        // Render insights
        function renderInsights() {
            const container = document.getElementById('insights');
            const insights = [];
            const currentYear = new Date().getFullYear();

            // Filter matches by type
            const singlesMatches = matches.filter(m => m.match_type === 'singles');
            const doublesMatches = matches.filter(m => m.match_type === 'doubles');
            const canadianMatches = matches.filter(m => m.match_type === 'canadian');

            // This year's matches
            const singlesThisYear = singlesMatches.filter(m => new Date(m.created_at).getFullYear() === currentYear);
            const doublesThisYear = doublesMatches.filter(m => new Date(m.created_at).getFullYear() === currentYear);

            // ========== DOUBLES INSIGHTS ==========

            // Track doubles team records this year
            const doublesTeamRecords = {};
            doublesThisYear.forEach(match => {
                const team1 = [match.player1, match.player2].sort().join(' & ');
                const team2 = [match.player3, match.player4].sort().join(' & ');
                const team1Won = match.winner1 === match.player1 || match.winner1 === match.player2;

                if (!doublesTeamRecords[team1]) doublesTeamRecords[team1] = { wins: 0, losses: 0 };
                if (!doublesTeamRecords[team2]) doublesTeamRecords[team2] = { wins: 0, losses: 0 };

                if (team1Won) {
                    doublesTeamRecords[team1].wins++;
                    doublesTeamRecords[team2].losses++;
                } else {
                    doublesTeamRecords[team2].wins++;
                    doublesTeamRecords[team1].losses++;
                }
            });

            // Find unbeaten doubles teams this year
            Object.entries(doublesTeamRecords).forEach(([team, record]) => {
                if (record.wins >= 1 && record.losses === 0) {
                    insights.push({
                        type: 'doubles',
                        priority: 10,
                        text: `üèÜ ${team} are unbeaten this year in doubles (${record.wins}-0)`
                    });
                }
            });

            // Best doubles team this year
            const bestDoublesTeam = Object.entries(doublesTeamRecords)
                .filter(([_, r]) => r.wins + r.losses >= 2)
                .sort((a, b) => (b[1].wins - b[1].losses) - (a[1].wins - a[1].losses))[0];
            if (bestDoublesTeam && bestDoublesTeam[1].wins > bestDoublesTeam[1].losses) {
                insights.push({
                    type: 'stat',
                    priority: 5,
                    text: `üë• ${bestDoublesTeam[0]} lead doubles this year: ${bestDoublesTeam[1].wins}-${bestDoublesTeam[1].losses}`
                });
            }

            // ========== DOUBLES CHEMISTRY ==========
            // Track each player's win rate with each partner
            if (doublesMatches.length >= 3) {
                const playerPartnerStats = {};
                PLAYERS.forEach(p => playerPartnerStats[p] = {});

                doublesMatches.forEach(match => {
                    const team1 = [match.player1, match.player2];
                    const team2 = [match.player3, match.player4];
                    const team1Won = match.winner1 === match.player1 || match.winner1 === match.player2;

                    // Track stats for team 1 players
                    team1.forEach(player => {
                        const partner = team1.find(p => p !== player);
                        if (!playerPartnerStats[player][partner]) {
                            playerPartnerStats[player][partner] = { wins: 0, losses: 0 };
                        }
                        if (team1Won) {
                            playerPartnerStats[player][partner].wins++;
                        } else {
                            playerPartnerStats[player][partner].losses++;
                        }
                    });

                    // Track stats for team 2 players
                    team2.forEach(player => {
                        const partner = team2.find(p => p !== player);
                        if (!playerPartnerStats[player][partner]) {
                            playerPartnerStats[player][partner] = { wins: 0, losses: 0 };
                        }
                        if (!team1Won) {
                            playerPartnerStats[player][partner].wins++;
                        } else {
                            playerPartnerStats[player][partner].losses++;
                        }
                    });
                });

                // Find best chemistry (player with highest win rate with a specific partner, min 2 matches)
                let bestChemistry = null;
                PLAYERS.forEach(player => {
                    Object.entries(playerPartnerStats[player]).forEach(([partner, stats]) => {
                        const total = stats.wins + stats.losses;
                        if (total >= 2) {
                            const winRate = stats.wins / total;
                            if (!bestChemistry || winRate > bestChemistry.winRate ||
                                (winRate === bestChemistry.winRate && stats.wins > bestChemistry.wins)) {
                                bestChemistry = {
                                    player,
                                    partner,
                                    wins: stats.wins,
                                    losses: stats.losses,
                                    winRate
                                };
                            }
                        }
                    });
                });

                if (bestChemistry && bestChemistry.winRate >= 0.6 && bestChemistry.wins >= 2) {
                    insights.push({
                        type: 'doubles',
                        priority: 6,
                        text: `ü§ù ${bestChemistry.player} & ${bestChemistry.partner} have great chemistry: ${bestChemistry.wins}-${bestChemistry.losses} together`
                    });
                }
            }

            // ========== SINGLES STREAKS ==========

            // Calculate current winning/losing streaks for each player
            const playerStreaks = {};
            PLAYERS.forEach(p => playerStreaks[p] = { type: null, count: 0 });

            // Go through matches chronologically (newest first) to find current streaks
            singlesMatches.forEach(match => {
                [match.player1, match.player2].forEach(player => {
                    if (!playerStreaks[player].type) {
                        const won = match.winner1 === player;
                        playerStreaks[player].type = won ? 'win' : 'loss';
                        playerStreaks[player].count = 1;
                    } else if (
                        (playerStreaks[player].type === 'win' && match.winner1 === player) ||
                        (playerStreaks[player].type === 'loss' && match.winner1 !== player)
                    ) {
                        playerStreaks[player].count++;
                    }
                });
            });

            // Report notable streaks (2+ matches)
            Object.entries(playerStreaks).forEach(([player, streak]) => {
                if (streak.count >= 2) {
                    if (streak.type === 'win') {
                        insights.push({
                            type: 'streak',
                            priority: streak.count >= 3 ? 8 : 5,
                            text: `üî• ${player} has won ${streak.count} singles matches in a row!`
                        });
                    } else if (streak.count >= 3) {
                        insights.push({
                            type: 'cold',
                            priority: 6,
                            text: `‚ùÑÔ∏è ${player} is on a ${streak.count}-match losing streak in singles`
                        });
                    }
                }
            });

            // ========== HEAD TO HEAD RECORDS ==========

            const h2h = {};
            singlesMatches.forEach(match => {
                const key = [match.player1, match.player2].sort().join('_');
                if (!h2h[key]) h2h[key] = { matches: [], players: [match.player1, match.player2].sort() };
                h2h[key].matches.push(match);
            });

            Object.values(h2h).forEach(record => {
                const [p1, p2] = record.players;
                const p1Wins = record.matches.filter(m => m.winner1 === p1).length;
                const p2Wins = record.matches.length - p1Wins;

                // "Never beaten" - one player has 0 wins with multiple matches
                if (record.matches.length >= 2) {
                    if (p1Wins === 0) {
                        insights.push({
                            type: 'dominance',
                            priority: 9,
                            text: `üíÄ ${p1} has never beaten ${p2} in singles (0-${p2Wins})`
                        });
                    } else if (p2Wins === 0) {
                        insights.push({
                            type: 'dominance',
                            priority: 9,
                            text: `üíÄ ${p2} has never beaten ${p1} in singles (0-${p1Wins})`
                        });
                    }
                }

                // H2H dominance (70%+ win rate with 5+ matches)
                if (record.matches.length >= 5) {
                    const dominant = p1Wins > p2Wins ? p1 : p2;
                    const dominated = p1Wins > p2Wins ? p2 : p1;
                    const dominantWins = Math.max(p1Wins, p2Wins);
                    const dominatedWins = Math.min(p1Wins, p2Wins);
                    const ratio = dominantWins / record.matches.length;
                    if (ratio >= 0.7) {
                        insights.push({
                            type: 'stat',
                            priority: 4,
                            text: `üìä ${dominant} dominates ${dominated} in singles: ${dominantWins}-${dominatedWins}`
                        });
                    }
                }

                // Recent H2H streak (last 3+ matches against same opponent)
                if (record.matches.length >= 3) {
                    const recentWinner = record.matches[0].winner1;
                    let streak = 0;
                    for (const match of record.matches) {
                        if (match.winner1 === recentWinner) streak++;
                        else break;
                    }
                    if (streak >= 3) {
                        const opponent = recentWinner === p1 ? p2 : p1;
                        insights.push({
                            type: 'streak',
                            priority: 7,
                            text: `üéØ ${recentWinner} has won the last ${streak} matches against ${opponent}`
                        });
                    }
                }
            });

            // ========== RAT FACTOR INSIGHTS ==========

            if (canadianMatches.length >= 3) {
                // Track wins (1st place finishes)
                const ratFactorWins = {};
                PLAYERS.forEach(p => ratFactorWins[p] = 0);

                canadianMatches.forEach(match => {
                    const players = [
                        { name: match.player1, score: match.score_player1 },
                        { name: match.player2, score: match.score_player2 },
                        { name: match.player3, score: match.score_player3 }
                    ].sort((a, b) => b.score - a.score);
                    if (players[0].name) ratFactorWins[players[0].name]++;
                });

                // Rat Factor king
                const ratKing = Object.entries(ratFactorWins).sort((a, b) => b[1] - a[1])[0];
                if (ratKing[1] >= 3) {
                    insights.push({
                        type: 'stat',
                        priority: 5,
                        text: `üêÄ ${ratKing[0]} is the Rat Factor king with ${ratKing[1]} wins`
                    });
                }

                // Recent form
                const recentScores = {};
                PLAYERS.forEach(p => recentScores[p] = []);

                canadianMatches.slice(0, 5).forEach(match => {
                    if (match.player1) recentScores[match.player1].push(match.score_player1);
                    if (match.player2) recentScores[match.player2].push(match.score_player2);
                    if (match.player3) recentScores[match.player3].push(match.score_player3);
                });

                PLAYERS.forEach(player => {
                    const scores = recentScores[player];
                    if (scores.length >= 3) {
                        const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
                        if (avg >= 9) {
                            insights.push({
                                type: 'streak',
                                priority: 6,
                                text: `üìà ${player} is on fire in Rat Factor! Avg ${avg.toFixed(1)} pts recently`
                            });
                        } else if (avg <= 4) {
                            insights.push({
                                type: 'cold',
                                priority: 3,
                                text: `üìâ ${player} is struggling in Rat Factor (avg ${avg.toFixed(1)} pts)`
                            });
                        }
                    }
                });

                // Clutch player - wins close Rat Factor games (winner within 2 points of 2nd place)
                const clutchWins = {};
                PLAYERS.forEach(p => clutchWins[p] = 0);

                canadianMatches.forEach(match => {
                    const players = [
                        { name: match.player1, score: match.score_player1 },
                        { name: match.player2, score: match.score_player2 },
                        { name: match.player3, score: match.score_player3 }
                    ].sort((a, b) => b.score - a.score);

                    // Close game = 1st and 2nd place within 2 points
                    const margin = players[0].score - players[1].score;
                    if (margin <= 2 && players[0].name) {
                        clutchWins[players[0].name]++;
                    }
                });

                const clutchLeader = Object.entries(clutchWins).sort((a, b) => b[1] - a[1])[0];
                if (clutchLeader[1] >= 2) {
                    insights.push({
                        type: 'streak',
                        priority: 7,
                        text: `üéØ ${clutchLeader[0]} is clutch! ${clutchLeader[1]} wins in close Rat Factor games`
                    });
                }
            }

            // ========== OVERALL STATS ==========

            // Singles win leader this year
            if (singlesThisYear.length > 0) {
                const winCountsThisYear = {};
                PLAYERS.forEach(p => winCountsThisYear[p] = 0);
                singlesThisYear.forEach(m => {
                    if (m.winner1) winCountsThisYear[m.winner1]++;
                });
                const topWinner = Object.entries(winCountsThisYear).sort((a, b) => b[1] - a[1])[0];
                if (topWinner[1] >= 1) {
                    insights.push({
                        type: 'stat',
                        priority: topWinner[1] >= 3 ? 5 : 3,
                        text: `üëë ${topWinner[0]} leads ${currentYear} singles with ${topWinner[1]} win${topWinner[1] > 1 ? 's' : ''}`
                    });
                }
            }

            // Most active player
            const matchCounts = {};
            PLAYERS.forEach(p => matchCounts[p] = 0);
            matches.forEach(m => {
                if (m.player1) matchCounts[m.player1]++;
                if (m.player2) matchCounts[m.player2]++;
                if (m.player3) matchCounts[m.player3]++;
                if (m.player4) matchCounts[m.player4]++;
            });
            const sortedByMatches = Object.entries(matchCounts).sort((a, b) => b[1] - a[1]);
            const mostActive = sortedByMatches[0];
            const secondMostActive = sortedByMatches[1];
            // Only show if there's a clear leader (no tie for first)
            if (mostActive[1] >= 3 && mostActive[1] > secondMostActive[1]) {
                insights.push({
                    type: 'stat',
                    priority: 2,
                    text: `üéæ ${mostActive[0]} has played the most matches: ${mostActive[1]} total`
                });
            }

            // Total matches played
            if (matches.length > 0) {
                insights.push({
                    type: 'stat',
                    priority: 1,
                    text: `üìä ${matches.length} total matches logged`
                });
            }

            // ========== RENDER ==========

            if (insights.length === 0) {
                container.innerHTML = '<div class="empty-state">Play more matches to unlock insights!</div>';
                return;
            }

            // Sort by priority and take top insights
            insights.sort((a, b) => (b.priority || 0) - (a.priority || 0));

            // Helper to format insight text with highlighted player names
            function formatInsight(text) {
                // Extract emoji from start
                const emojiMatch = text.match(/^(\p{Emoji})\s*/u);
                const emoji = emojiMatch ? emojiMatch[1] : 'üìä';
                const textWithoutEmoji = emojiMatch ? text.slice(emojiMatch[0].length) : text;

                // Highlight player names
                let formatted = textWithoutEmoji;
                PLAYERS.forEach(player => {
                    formatted = formatted.replace(new RegExp(`\\b${player}\\b`, 'g'), `<strong>${player}</strong>`);
                });

                // Also highlight team pairs like "Ed & Tom"
                formatted = formatted.replace(/(\w+)\s*&amp;\s*(\w+)/g, '<strong>$1 & $2</strong>');
                formatted = formatted.replace(/(\w+)\s*&\s*(\w+)/g, '<strong>$1 & $2</strong>');

                return { emoji, text: formatted };
            }

            container.innerHTML = insights.slice(0, 6).map(insight => {
                const { emoji, text } = formatInsight(insight.text);
                return `
                    <div class="insight-item ${insight.type}">
                        <span class="insight-emoji">${emoji}</span>
                        <span class="insight-text">${text}</span>
                    </div>
                `;
            }).join('');
        }

        // H2H comprehensive view
        function renderH2H() {
            const container = document.getElementById('h2hGrid');
            const singlesMatches = matches.filter(m => m.match_type === 'singles');

            if (singlesMatches.length === 0) {
                container.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üéæ</div>No singles matches recorded yet</div>';
                return;
            }

            // Group matches by year
            const matchesByYear = {};
            singlesMatches.forEach(match => {
                const year = new Date(match.created_at).getFullYear();
                if (!matchesByYear[year]) {
                    matchesByYear[year] = [];
                }
                matchesByYear[year].push(match);
            });

            // Sort years descending (newest first)
            const years = Object.keys(matchesByYear).sort((a, b) => b - a);

            // Generate all unique player combinations
            const matchups = [];
            for (let i = 0; i < PLAYERS.length; i++) {
                for (let j = i + 1; j < PLAYERS.length; j++) {
                    matchups.push([PLAYERS[i], PLAYERS[j]]);
                }
            }

            const yearSections = years.map(year => {
                const yearMatches = matchesByYear[year];

                const matchupHTML = matchups.map(([p1, p2]) => {
                    const h2hMatches = yearMatches.filter(m =>
                        (m.player1 === p1 && m.player2 === p2) || (m.player1 === p2 && m.player2 === p1)
                    );

                    if (h2hMatches.length === 0) {
                        return `
                            <div class="h2h-matchup">
                                <div class="h2h-players">
                                    <span class="h2h-player">${p1}</span>
                                    <span class="h2h-vs">VS</span>
                                    <span class="h2h-player">${p2}</span>
                                </div>
                                <div class="h2h-empty">No matches</div>
                            </div>
                        `;
                    }

                    const p1Wins = h2hMatches.filter(m => m.winner1 === p1).length;
                    const p2Wins = h2hMatches.length - p1Wins;

                    return `
                        <div class="h2h-matchup">
                            <div class="h2h-players">
                                <span class="h2h-player">${p1}</span>
                                <span class="h2h-vs">VS</span>
                                <span class="h2h-player">${p2}</span>
                            </div>
                            <div class="h2h-score">
                                <span class="h2h-score-number">${p1Wins}</span>
                                <span class="h2h-score-separator">-</span>
                                <span class="h2h-score-number">${p2Wins}</span>
                            </div>
                            <div class="h2h-matches">${h2hMatches.length} ${h2hMatches.length === 1 ? 'match' : 'matches'}</div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="h2h-year-section">
                        <div class="h2h-year-title">${year}</div>
                        <div class="h2h-grid">${matchupHTML}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = yearSections;
        }

        // Toast notification
        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Edit Match Modal Functions
        function openEditModal(matchId, currentLocation) {
            document.getElementById('editMatchId').value = matchId;
            document.getElementById('editLocation').value = currentLocation || '';
            document.getElementById('editModal').classList.add('show');
        }

        function closeEditModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('editModal').classList.remove('show');
        }

        async function saveMatchEdit() {
            const matchId = document.getElementById('editMatchId').value;
            const location = document.getElementById('editLocation').value.trim() || null;

            // Convert to number if it's a numeric ID
            const idValue = isNaN(matchId) ? matchId : parseInt(matchId);

            try {
                const { error } = await db
                    .from('matches')
                    .update({ location: location })
                    .eq('id', idValue);

                if (error) throw error;

                showToast('Match updated!');
                closeEditModal();
                await loadMatches();
            } catch (err) {
                console.error('Error updating match:', err);
                showToast('Error updating match', true);
            }
        }

        // Fighter Select Functions
        function openFighterSelect() {
            const overlay = document.getElementById('fighterSelect');
            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
            updateFighterStats();
        }

        function closeFighterSelect() {
            const overlay = document.getElementById('fighterSelect');
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }

        function updateFighterStats() {
            const singlesMatches = matches.filter(m => m.match_type === 'singles');

            PLAYERS.forEach(player => {
                const wins = singlesMatches.filter(m => m.winner1 === player).length;
                const losses = singlesMatches.filter(m =>
                    (m.player1 === player || m.player2 === player) && m.winner1 !== player
                ).length;

                const playerLower = player.toLowerCase();
                const winsEl = document.getElementById(`${playerLower}-wins`);
                const lossesEl = document.getElementById(`${playerLower}-losses`);

                if (winsEl) winsEl.textContent = wins;
                if (lossesEl) lossesEl.textContent = losses;
            });
        }

        // Close fighter select with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeFighterSelect();
            }
        });
    </script>
</body>
</html>
